# 笔记

## 前言

Spring Data R2DBC项目将Spring的核心概念应用于开发使用R2DBC驱动的关系数据库的解决方案。我们提供一个DatabaseClient作为存储和查询行的高级抽象。

本文档是Spring Data - R2DBC支持的参考指南。它解释了R2DBC模块的概念和语义。

## What is R2DBC?

R2DBC是Reactive Relational Database Connectivity的首字母缩写。R2DBC是一个API规范倡议，它声明了一个反应式API，由驱动厂商实现，以访问他们的关系数据库。

关于为什么要创建R2DBC的部分答案是，需要一个非阻塞的应用堆栈来处理少量线程的并发，并以较少的硬件资源进行扩展。这种需求不能通过重复使用标准化的关系数据库访问API（即JDBC）来满足，因为JDBC是一个完全阻塞的API。试图用线程池来补偿阻塞行为的做法，作用有限。

答案的另一部分是，大多数应用程序使用关系型数据库来存储他们的数据。虽然几个NoSQL数据库供应商为他们的数据库提供了反应式数据库客户端，但对于大多数项目来说，迁移到NoSQL不是一个选项。这就是建立一个新的通用API的动机，作为任何非阻塞数据库驱动的基础。虽然开源生态系统承载了各种非阻塞关系型数据库驱动的实现，但每个客户端都带有供应商特定的API，所以在这些库的基础上建立一个通用层是不可能的。

## What is Reactive?

术语 "反应式 "指的是围绕对变化、可用性和可处理性做出反应的编程模型--网络组件对I/O事件做出反应，UI控制器对鼠标事件做出反应，资源被提供，等等。在这个意义上，非阻塞是反应性的，因为我们现在不是被阻塞，而是在操作完成或数据可用时对通知做出反应的模式。

还有一个重要的机制，我们Spring团队将其与反应式联系在一起，那就是非阻塞的背压。在同步的、命令式的代码中，阻塞式调用是一种自然的背压形式，迫使调用者等待。在非阻塞代码中，控制事件的速度变得非常重要，这样快速的生产者就不会淹没其目的地。

Reactive Streams是一个小型规范（也在Java 9中采用），定义了异步组件与背压之间的交互。例如，一个数据存储库（作为Publisher）可以产生数据，然后由HTTP服务器（作为Subscriber）写入响应。反应流的主要目的是让订阅者控制发布者产生数据的速度或速度。

## Dependencies

由于各个Spring Data模块的起始日期不同，它们中的大多数都有不同的主要和次要版本号。找到兼容的模块最简单的方法是依靠Spring Data Release Train BOM，我们在发布时定义了兼容版本。在Maven项目中，你可以在POM的<dependencyManagement />部分声明这一依赖关系，如下所示。

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.data</groupId>
      <artifactId>spring-data-bom</artifactId>
      <version>2021.0.10</version>
      <scope>import</scope>
      <type>pom</type>
    </dependency>
  </dependencies>
</dependencyManagement>
```

声明对spring data的模块依赖

```xml
<dependencies>
  <dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-jpa</artifactId>
  </dependency>
<dependencies>
```

### Core concepts

Spring Data存储库抽象的中心接口是Repository。它把要管理的域类以及域类的ID类型作为类型参数。这个接口主要是作为一个标记接口，用来捕捉工作中的类型，并帮助你发现扩展这个接口的接口。CrudRepository接口为被管理的实体类提供复杂的CRUD功能。

```java
public interface CrudRepository<T, ID> extends Repository<T, ID> {

  <S extends T> S save(S entity);

  Optional<T> findById(ID primaryKey);

  Iterable<T> findAll();

  long count();

  void delete(T entity);

  boolean existsById(ID primaryKey);

  // … more functionality omitted.
}
```

我们还提供了持久化技术的特定抽象，如JpaRepository或MongoRepository。这些接口扩展了CrudRepository，除了像CrudRepository这样相当通用的持久化技术的接口之外，还暴露了底层持久化技术的能力。

在CrudRepository之上，有一个PagingAndSortingRepository的抽象，它增加了额外的方法以方便对实体的分页访问。

```java
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {

  Iterable<T> findAll(Sort sort);

  Page<T> findAll(Pageable pageable);
}
```

要按20的页面大小访问用户的第二页，你可以做如下的事情。

```java
PagingAndSortingRepository<User, Long> repository = // … get access to a bean
Page<User> users = repository.findAll(PageRequest.of(1, 20));
```

### 定义crud

```java
long countByLastname(String lastname);
long deleteByLastname(String lastname);
List<User> removeByLastname(String lastname);
List<Person> findByLastname(String lastname);
```

#### Property Expressions

```java
List<Person> findByAddressZipCode(ZipCode zipCode);
List<Person> findByAddress_ZipCode(ZipCode zipCode);
```

#### Special parameter handling

```java
Page<User> findByLastname(String lastname, Pageable pageable);
Slice<User> findByLastname(String lastname, Pageable pageable);
List<User> findByLastname(String lastname, Sort sort);
List<User> findByLastname(String lastname, Pageable pageable);
```

#### Paging and Sorting

```java
Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());

TypedSort<Person> person = Sort.sort(Person.class);
Sort sort = person.by(Person::getFirstname).ascending()
  .and(person.by(Person::getLastname).descending());
```

#### Limiting Query Results

```java
User findFirstByOrderByLastnameAsc();
User findTopByOrderByAgeDesc();
Page<User> queryFirst10ByLastname(String lastname, Pageable pageable);
Slice<User> findTop3ByLastname(String lastname, Pageable pageable);
List<User> findFirst10ByLastname(String lastname, Sort sort);
List<User> findTop10ByLastname(String lastname, Pageable pageable);
```

### Null Handling of Repository Methods

从Spring Data 2.0开始，返回单个聚合实例的存储库CRUD方法使用Java 8的Optional来指示可能没有的值。除此之外，Spring Data还支持在查询方法上返回以下封装类型。

#### Nullability Annotations

你可以通过使用Spring Framework的nullability注解来表达存储库方法的nullability约束。它们提供了一种工具友好的方法，并在运行时选择加入空值检查，如下所示。

@NonNullApi: 在包的层面上使用，声明参数和返回值的默认行为分别是不接受也不产生空值。
@NonNull。用于不得为空的参数或返回值（在适用@NonNullApi的参数和返回值上不需要）。
@Nullable。用在可以为空的参数或返回值上。

```java
@org.springframework.lang.NonNullApi
package com.acme; // 存储库驻留在一个包（或子包）中，我们为其定义了非空的行为。

import org.springframework.lang.Nullable;

interface UserRepository extends Repository<User, Long> {
  // // 当查询没有产生结果时，抛出一个EmptyResultDataAccessException。当交给该方法的emailAddress为空时，抛出一个IllegalArgumentException。
  User getByEmailAddress(EmailAddress emailAddress);

  // 当查询没有产生结果时，返回null。也接受null作为emailAddress的值。
  @Nullable
  User findByEmailAddress(@Nullable EmailAddress emailAdress);

  // 当查询没有产生结果时返回Optional.empty()。当交给该方法的emailAddress为null时，抛出一个IllegalArgumentException。
  Optional<User> findOptionalByEmailAddress(EmailAddress emailAddress);
}
```

## R2DBC support

建立工作环境的一个简单方法是通过start.spring.io创建一个基于Spring的项目。要做到这一点。

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>io.r2dbc</groupId>
      <artifactId>r2dbc-bom</artifactId>
      <version>${r2dbc-releasetrain.version}</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>

  <!-- other dependency elements omitted -->

  <dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-r2dbc</artifactId>
    <version>1.3.10</version>
  </dependency>

  <!-- a R2DBC driver -->
  <dependency>
    <groupId>io.r2dbc</groupId>
    <artifactId>r2dbc-h2</artifactId>
    <version>Arabba-SR13</version>
  </dependency>
</dependencies>
```


```properties
logging.level.org.springframework.r2dbc=DEBUG
```


```java
@Data
public class Person {

  private final String id;
  private final String name;
  private final int age;

  public Person(String id, String name, int age) {
    this.id = id;
    this.name = name;
    this.age = age;
  }
}
```

```sql
CREATE TABLE person
  (id VARCHAR(255) PRIMARY KEY,
   name VARCHAR(255),
   age INT);
```

```java
import io.r2dbc.spi.ConnectionFactories;
import io.r2dbc.spi.ConnectionFactory;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import reactor.test.StepVerifier;

import org.springframework.data.r2dbc.core.R2dbcEntityTemplate;

public class R2dbcApp {

  private static final Log log = LogFactory.getLog(R2dbcApp.class);

  public static void main(String[] args) {

    ConnectionFactory connectionFactory = ConnectionFactories.get("r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE");

    R2dbcEntityTemplate template = new R2dbcEntityTemplate(connectionFactory);

    template.getDatabaseClient().sql("CREATE TABLE person" +
        "(id VARCHAR(255) PRIMARY KEY," +
        "name VARCHAR(255)," +
        "age INT)")
      .fetch()
      .rowsUpdated()
      .as(StepVerifier::create)
      .expectNextCount(1)
      .verifyComplete();

    template.insert(Person.class)
      .using(new Person("joe", "Joe", 34))
      .as(StepVerifier::create)
      .expectNextCount(1)
      .verifyComplete();

    template.select(Person.class)
      .first()
      .doOnNext(it -> log.info(it))
      .as(StepVerifier::create)
      .expectNextCount(1)
      .verifyComplete();
  }
}
```

即使在这个简单的例子中，也有一些事情需要注意。
你可以通过使用标准的io.r2dbc.spi.ConnectionFactory对象来创建Spring Data R2DBC的中心辅助类（R2dbcEntityTemplate）的实例。
该映射器针对标准的POJO对象工作，不需要任何额外的元数据（尽管你可以选择性地提供这些信息--见这里）。
映射约定可以使用字段访问。注意，Person类只有getters。
如果构造函数的参数名与存储行的列名相匹配，它们就会被用来实例化对象。

### R2DBC Repositories

本章指出了R2DBC的存储库支持的专业性。本章建立在Working with Spring Data Repositories中解释的核心资源库支持的基础上。在阅读本章之前，你应该对那里解释的基本概念有一个正确的理解。

#### Usage

```java
public class Person {

  @Id
  private Long id;
  private String firstname;
  private String lastname;

  // … getters and setters omitted
}
```

```java
public interface PersonRepository extends ReactiveCrudRepository<Person, Long> {

  // additional custom query methods go here
}
```

为了配置R2DBC存储库，你可以使用@EnableR2dbcRepositories注解。如果没有配置基础包，基础设施会扫描注释的配置类的包。下面的例子展示了如何为一个存储库使用Java配置。

```java
@Configuration
@EnableR2dbcRepositories
class ApplicationConfig extends AbstractR2dbcConfiguration {

  @Override
  public ConnectionFactory connectionFactory() {
    return …
  }
}
```

因为我们的域仓库扩展了ReactiveCrudRepository，它为你提供了反应式CRUD操作来访问实体。在ReactiveCrudRepository之上，还有ReactiveSortingRepository，它增加了类似于PagingAndSortingRepository的额外排序功能。使用资源库实例仅仅是将其依赖性注入到客户端的问题。因此，你可以用以下代码检索所有的Person对象。

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration
class PersonRepositoryTests {

  @Autowired
  PersonRepository repository;

  @Test
  void readsAllEntitiesCorrectly() {

    repository.findAll()
      .as(StepVerifier::create)
      .expectNextCount(1)
      .verifyComplete();
  }

  @Test
  void readsEntitiesByNameCorrectly() {

    repository.findByFirstname("Hello World")
      .as(StepVerifier::create)
      .expectNextCount(1)
      .verifyComplete();
  }
}
```

前面的例子用Spring的单元测试支持创建了一个应用程序上下文，它将基于注解的依赖注入到测试案例中。

#### Query Methods

你通常在版本库上触发的大多数数据访问操作都会导致对数据库运行查询。定义这样的查询只需要在版本库接口上声明一个方法，就像下面的例子所示。

```java
interface ReactivePersonRepository extends ReactiveSortingRepository<Person, Long> {

  Flux<Person> findByFirstname(String firstname);

  Flux<Person> findByFirstname(Publisher<String> firstname);

  Flux<Person> findByFirstnameOrderByLastname(String firstname, Pageable pageable);

  Mono<Person> findByFirstnameAndLastname(String firstname, String lastname);

  Mono<Person> findFirstByLastname(String lastname);

  @Query("SELECT * FROM person WHERE lastname = :lastname")
  Flux<Person> findByLastname(String lastname);

  @Query("SELECT firstname, lastname FROM person WHERE lastname = $1")
  Mono<Person> findFirstByLastname(String lastname);
}
```

该方法显示了对所有具有给定名字的人的查询。这个查询是通过解析方法名称中可以与And和Or相连接的约束条件而得到的。因此，方法名称的结果是一个查询表达式：SELECT ... FROM person WHERE firstname = :firstname。

一旦给定的Publisher发出了firstname，该方法就会显示对所有具有给定firstname的人的查询。

使用Pageable向数据库传递偏移和排序参数。

为给定的标准找到一个单一的实体。它在非唯一的结果上以IncorrectResultSizeDataAccessException完成。

除非<4>，否则即使查询产生了更多的结果行，也总是发出第一个实体。

findByLastname方法显示对所有具有给定姓氏的人的查询。

对单个Person实体的查询，只投射了firstname和lastname列。
注释的查询使用了本地绑定标记，在这个例子中是Postgres的绑定标记。