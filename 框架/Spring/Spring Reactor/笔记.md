# Spring Reactor

## 响应式编程简介

Reactor是反应式编程范式的一个实现，它可以被总结为以下几点。

> 反应式编程是一种关注数据流和变化传播的异步编程范式。这意味着可以通过采用的编程语言轻松表达静态（如数组）或动态（如事件发射器）数据流。

作为向反应式编程方向迈出的第一步，微软在.NET生态系统中创建了反应式扩展（Rx）库。然后，RxJava在JVM上实现了反应式编程。随着时间的推移，通过Reactive Streams的努力出现了Java的标准化，这个规范为JVM上的反应式库定义了一套接口和交互规则。它的接口已被整合到Java 9的Flow类下。

在面向对象的语言中，反应式编程范式常常作为观察者设计模式的扩展而呈现。你也可以将主要的反应式流模式与我们熟悉的Iterator设计模式进行比较，因为在所有这些库中，Iterable-Iterator对存在着双重性。一个主要的区别是，Iterator是基于拉的，而反应式流是基于推的。

使用迭代器是一种命令式的编程模式，尽管访问值的方法完全由Iterable负责。事实上，是由开发者来选择何时访问序列中的next()。在反应式流中，上述一对的等价物是发布者-订阅者。但正是Publisher在新的可用值到来时通知Subscriber，这个推送方面是反应式的关键所在。另外，应用于推送值的操作是以声明的方式表达的，而不是强制性的。程序员表达的是计算的逻辑，而不是描述其确切的控制流程。

除了推送值之外，错误处理和完成方面也以一种很好的方式被涵盖。发布者可以向其订阅者推送新值（通过调用onNext），但也可以发出错误信号（通过调用onError）或完成信号（通过调用onComplete）。错误和完成都会终止该序列。这可以归纳为以下几点。

```shell
onNext x 0..N [onError | onComplete]
```

这种方法是非常灵活的。该模式支持没有值、一个值或n个值的用例（包括无限的值序列，如时钟的持续跳动）。

但是，为什么我们首先需要这样一个异步的反应式库呢？

### 阻塞会浪费资源

现代应用程序可以达到巨大的并发用户数量，而且，即使现代硬件的能力不断提高，现代软件的性能仍然是一个关键问题。

大体上，有两种方法可以提高程序的性能。
- 并行化以使用更多的线程和更多的硬件资源。
- 在如何使用现有资源方面寻求更高的效率。

通常情况下，Java开发者通过使用阻塞代码来编写程序。这种做法很好，直到出现性能瓶颈。然后就是引入额外的线程，运行类似的阻塞代码。但是，这种资源利用的扩展会很快引入竞争和并发问题。

更糟糕的是，阻塞会浪费资源。如果你仔细观察，只要一个程序涉及一些延迟（特别是I/O，如数据库请求或网络调用），资源就被浪费了，因为线程（可能是许多线程）现在闲置，等待数据。

因此，并行化方法不是银弹。要想获得硬件的全部力量，它是必要的，但它的推理也很复杂，容易造成资源浪费。

### 异步的实现？

前面提到的第二种方法，寻求更多的效率，可以成为解决资源浪费问题的一个办法。通过编写异步的、非阻塞的代码，你可以让执行切换到另一个使用相同底层资源的活动任务，之后在异步处理完成后再回到当前进程。

但如何在JVM上产生异步代码呢？Java提供了两种异步编程的模式。
- Callbacks: 异步方法没有返回值，但需要一个额外的回调参数（一个lambda或匿名类），当结果可用时就会被调用。一个众所周知的例子是Swing的EventListener层次结构。
- Futures: 异步方法立即返回一个Future<T>。异步过程计算了一个T值，但Future对象包裹了对它的访问。该值不是立即可用的，并且该对象可以被轮询，直到该值可用。例如，一个运行Callable<T>任务的ExecutorService使用Future对象。

这些技术足够好吗？并非每个用例都是如此，而且这两种方法都有局限性。

回调很难组合在一起，很快就会导致代码难以阅读和维护（被称为 "回调地狱"）。

考虑一个例子：在用户界面上显示一个用户的前五个最爱，或者在她没有最爱的情况下提供建议。这要经过三个服务（一个是提供最爱的ID，第二个是获取最爱的细节，第三个是提供建议的细节），如下所示。

```java
userService.getFavorites(userId, new Callback<List<String>>() { // 我们有基于回调的服务：一个回调接口，当异步过程成功时调用一个方法，当发生错误时调用一个方法。
  public void onSuccess(List<String> list) { // 第一个服务用喜爱的ID列表调用它的回调。
    if (list.isEmpty()) { // 如果列表是空的，我们必须去找 suggestionService。
      suggestionService.getSuggestions(new Callback<List<Favorite>>() {
        public void onSuccess(List<Favorite> list) { // suggestionService给了第二个回调一个List<Favorite>。
          UiUtils.submitOnUiThread(() -> { // 由于我们处理的是一个用户界面，我们需要确保我们的消费代码在用户界面线程中运行。
            list.stream()
                .limit(5)
                .forEach(uiList::show); // 我们使用一个Java 8流来限制处理的建议数量为5个，并在用户界面中以图形列表的方式显示这些建议。
            });
        }

        public void onError(Throwable error) { // 在每个级别，我们都以同样的方式处理错误。我们在一个弹出窗口中显示它们。
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() // 返回到最爱的ID级别。如果服务返回了一个完整的列表，我们需要到favoriteService去获得详细的Favorite对象。因为我们只想要五个，所以我们首先流化ID列表，将其限制为五个。
          .limit(5)
          .forEach(favId -> favoriteService.getDetails(favId, // 再一次，一个回调。这一次，我们得到一个成熟的Favorite对象，并将其推送到UI线程中。
            new Callback<Favorite>() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -> uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});
```

这是大量的代码，而且有点难以理解，有重复的部分。考虑一下它在Reactor中的等价物。

```java
userService.getFavorites(userId) // 我们从最喜欢的ID的流程开始。
    .flatMap(favoriteService::getDetails) // 我们异步地将这些转化为详细的喜爱对象（flatMap）。我们现在有一个Favorite的流程。
    .switchIfEmpty(suggestionService.getSuggestions()) // 如果 "最爱"流是空的，我们就通过建议服务（insustantiveService）切换到后退。
    .take(5) // 我们最多只对产生的流量中的五个元素感兴趣。
    .publishOn(UiUtils.uiThreadScheduler()) // 最后，我们要在UI线程中处理每一条数据。
    .subscribe(uiList::show, UiUtils::errorPopup); // 我们通过描述如何处理数据的最终形式（在用户界面列表中显示）以及在出现错误时如何处理（显示一个弹出窗口）来触发流程。
```

如果你想确保在800ms内检索到最喜欢的ID，或者如果需要更长的时间，从缓存中获取它们，怎么办？在基于回调的代码中，这是个复杂的任务。在Reactor中，这变得很简单，只要在链中添加一个超时操作符，如下所示。

```java
userService.getFavorites(userId)
    .timeout(Duration.ofMillis(800)) // 如果上面的部分在800ms以上没有发出数据，则传播一个错误。
    .onErrorResume(cacheService.cachedFavoritesFor(userId)) // 如果出现错误，则退回到cacheService。
    .flatMap(favoriteService::getDetails)
    .switchIfEmpty(suggestionService.getSuggestions()) // 链条的其余部分与之前的例子类似。
    .take(5)
    .publishOn(UiUtils.uiThreadScheduler())
    .subscribe(uiList::show, UiUtils::errorPopup);
```

Future对象比回调要好一些，但它们在组合方面仍然做得不好，尽管Java 8中CompletableFuture带来了改进。将多个Future对象编排在一起是可以做到的，但并不容易。另外，Future还有其他问题。
- 通过调用get()方法，Future对象很容易出现另一个阻塞的情况。
- 它们不支持懒惰的计算。
- 它们缺乏对多值和高级错误处理的支持。

考虑另一个例子。我们得到一个ID的列表，我们想从中获取一个名字和一个统计数字，并将这些配对起来，所有这些都是异步的。下面的例子用一个类型为CompletableFuture的列表来实现。

```java
CompletableFuture<List<String>> ids = ifhIds(); // 我们从一个未来开始，给我们一个要处理的id值的列表。

CompletableFuture<List<String>> result = ids.thenComposeAsync(l -> { // 我们想在得到列表后开始一些更深入的异步处理。
    Stream<CompletableFuture<String>> zip = l.stream().map(i -> { // 遍历列表每个元素
        CompletableFuture<String> nameTask = ifhName(i); // 异步地获得相关的名称
        CompletableFuture<Integer> statTask = ifhStat(i); // 异步获取相关任务。
        return nameTask.thenCombineAsync(statTask, (name, stat) -> "Name " + name + " has stats " + stat); // 将两个结果结合起来。
    });
    List<CompletableFuture<String>> combinationList = zip.collect(Collectors.toList()); // 我们现在有一个代表所有组合任务的Future列表。为了执行这些任务，我们需要将这个列表转换为一个数组。
    CompletableFuture<String>[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

    CompletableFuture<Void> allDone = CompletableFuture.allOf(combinationArray); // 将数组传递给CompletableFuture.allOf，它输出一个当所有任务都完成时才完成的Future。
    return allDone.thenApply(v -> combinationList.stream()
        .map(CompletableFuture::join) // 棘手的是allOf返回CompletableFuture<Void>，所以我们重申了期货列表，用join()来收集它们的结果（在这里，它不会阻塞，因为allOf确保了期货都完成了）。
        .collect(Collectors.toList())); // 一旦整个异步管道被触发，我们等待它被处理，并返回我们可以断言的结果列表。
});

List<String> results = result.join();
assertThat(results).contains(
    "Name NameJoe has stats 103",
    "Name NameBart has stats 104",
    "Name NameHenry has stats 105",
    "Name NameNicole has stats 106",
    "Name NameABSLAJNFOAJNFOANFANSF has stats 121");
```

由于Reactor有更多的组合操作者出场，这个过程可以简化，如下所示。

```java
Flux<String> ids = ifhrIds(); // 这一次，我们从一个异步提供的id序列（一个Flux<String>）开始。

Flux<String> combinations = ids.flatMap(id -> { // 对于序列中的每个元素，我们异步地处理它（在作为主体的flatMap调用的函数内）两次
    Mono<String> nameTask = ifhrName(id); // 获取相关名称。
    Mono<Integer> statTask = ifhrStat(id); // 获得相关的统计资料。
    return nameTask.zipWith(statTask, (name, stat) -> "Name " + name + " has stats " + stat); // 异步结合这两个值。
});

Mono<List<String>> result = combinations.collectList(); // 当这些值可用时，将其汇总到一个列表中。

List<String> results = result.block(); // 在生产中，我们将继续以异步方式处理Flux，进一步组合它或订阅它。最有可能的是，我们会返回Mono的结果。因为我们是在测试中，所以我们改为阻塞，等待处理完成，然后直接返回聚合的值列表。
assertThat(results).containsExactly(
    "Name NameJoe has stats 103",
    "Name NameBart has stats 104",
    "Name NameHenry has stats 105",
    "Name NameNicole has stats 106",
    "Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);
```
使用回调和Future对象的危险性是相似的，这也是反应式编程用Publisher-Subscriber对解决的问题。

### 从指令性编程到反应性编程

反应式库，如Reactor，旨在解决JVM上 "经典 "异步方法的这些缺点，同时也关注一些其他方面。
- 可组合性和可读性
- 将数据作为一个流，用丰富的运算符词汇进行操作
- 在你订阅之前什么都不会发生
- 背压或消费者向生产者发出信号说排放率过高的能力
- 高水平但高价值的抽象，与并发性无关

## Reactor-core

Reactor项目的主要成果是reactor-core，一个专注于Reactive Streams规范的反应式库，目标是Java 8。

Reactor引入了可组合的反应式类型，实现了Publisher，但也提供了丰富的操作符词汇。Flux和Mono。Flux对象代表一个由0...N个项目组成的反应式序列，而Mono对象代表一个单值或空值（0...1）的结果。

这种区别在类型中携带了一点语义信息，表明了异步处理的粗略的cardinality。例如，一个HTTP请求只产生一个响应，所以做一个计数操作没有什么意义。因此，将这种HTTP调用的结果表达为Mono<HttpResponse>比表达为Flux<HttpResponse>更有意义，因为它只提供与零项或一项的上下文相关的操作符。

改变处理的最大cardinality的操作符也会切换到相关类型。例如，Flux中存在计数操作符，但它返回的是Mono<Long>。

### Flux，一个0-N项的异步序列

下图显示了Flux是如何转换项目的。

![Flux，一个0-N项的异步序列](vx_images/543044010226747.png =864x)

Flux<T>是一个标准的Publisher<T>，它代表了一个由0到N个发射项组成的异步序列，可以选择由一个完成信号或一个错误终止。在Reactive Streams规范中，这三种类型的信号转化为对下游订阅者的onNext、onComplete和onError方法的调用。

有了这个大范围的可能的信号，Flux是通用的反应式类型。请注意，所有的事件，甚至是终止的事件，都是可选的：没有onNext事件，但有onComplete事件，代表了一个空的有限序列，但除去onComplete，你就有一个无限的空序列（不是特别有用，除了围绕取消的测试）。同样地，无限序列也不一定是空的。例如，Flux.interval(Duration)产生一个Flux<Long>，它是无限的，并从一个时钟发出有规律的滴答声。

### Mono，一个异步的0-1结果

下图显示了Mono如何转换一个项目。

![Mono，一个异步的0-1结果](vx_images/189464410239582.png =872x)

Mono<T>是一个专门的Publisher<T>，它通过onNext信号最多发出一个项目，然后以onComplete信号结束（成功的Mono，有或没有价值），或者只发出一个onError信号（失败的Mono）。

大多数Mono实现都希望在调用onNext后立即对其订阅者调用onComplete。Mono.never()是一个例外：它不发出任何信号，这在技术上并不被禁止，尽管在测试之外并不十分有用。另一方面，onNext和onError的组合是被明确禁止的。

Mono只提供了Flux可用的操作符的一个子集，一些操作符（特别是那些将Mono与另一个Publisher结合起来的操作符）切换到Flux。例如，Mono#concatWith(Publisher)返回一个Flux，而Mono#then(Mono)返回另一个Mono。

请注意，你可以用Mono来表示无价值的异步进程，它只有完成的概念（类似于Runnable）。要创建一个，你可以使用一个空的Mono<Void>。

### 创建 flux 或 Mono 与订阅

开始使用Flux和Mono的最简单方法是使用它们各自类中的众多工厂方法之一。

例如，要创建一个String序列，你可以枚举它们，或者把它们放在一个集合中，然后从其中创建Flux，如下所示。

```java
Flux<String> seq1 = Flux.just("foo", "bar", "foobar");

List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);
```

工厂方法的其他例子包括如下。

```java
Mono<String> noData = Mono.empty();

Mono<String> data = Mono.just("foo");

Flux<Integer> numbersFromFiveToSeven = Flux.range(5, 3);
```

当涉及到订阅时，Flux和Mono使用了Java 8 lambdas。你有很多.subscribe()的变体可供选择，这些变体为不同的回调组合使用lambdas，如下面的方法签名所示。

```java
subscribe(); // 订阅并触发该序列。

subscribe(Consumer<? super T> consumer); // 对每个产生的数据流做一些事情。

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); // 处理数据流问题，但也要对错误做出反应。

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); // 处理数值和错误，但也在序列成功完成时运行一些代码。

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); // 处理值、错误和成功完成，但也要对这个订阅调用所产生的订阅做一些事情。
```

> 这些变体返回一个对订阅的引用，当不需要更多的数据时，你可以用它来取消订阅。在取消时，源应该停止产生值并清理它所创建的任何资源。这种取消和清理行为在Reactor中由通用的Disposable接口表示。

#### subscribe Method Examples

本节包含了订阅方法的五个签名中每个签名的最小例子。下面的代码显示了一个没有参数的基本方法的例子。

```java
Flux<Integer> ints = Flux.range(1, 3); // 设置一个Flux，当订阅者加入时产生三个值。
ints.subscribe(); // 以最简单的方式订阅。
```

前面的代码没有产生可见的输出，但它确实在工作。Flux产生三个值。如果我们提供一个lambda，我们可以让这些值变得可见。下一个关于订阅方法的例子显示了一种使数值出现的方法。

```java
Flux<Integer> ints = Flux.range(1, 3); // 设置一个Flux，当订阅者加入时产生三个值。
ints.subscribe(i -> System.out.println(i)); // 用一个将打印这些值的订阅者订阅。
```

为了演示下一个签名，我们故意引入一个错误，如下面的例子所示。

```java
Flux<Integer> ints = Flux.range(1, 4)
      .map(i -> {
        if (i <= 3) return i;
        throw new RuntimeException("Got to 4");
      });
ints.subscribe(i -> System.out.println(i),
      error -> System.err.println("Error: " + error));
```

订阅方法的下一个签名包括一个错误处理程序和一个完成事件的处理程序，如下例所示。

```java
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(i -> System.out.println(i),
    error -> System.err.println("Error " + error),
    () -> System.out.println("Done")); // 用一个包括完成事件处理程序的订阅者订阅。
```

订阅方法的最后一个签名包括一个消费者<Subscription>。

> 这个变体要求你对订阅号做些什么（对它执行一个request(long)或cancel()它）。否则Flux会挂起。

下面的例子显示了订阅方法的最后一个签名。

```java
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(i -> System.out.println(i),
    error -> System.err.println("Error " + error),
    () -> System.out.println("Done"),
    sub -> sub.request(10)); // 当我们订阅时，我们会收到一个订阅。信号，我们希望从源头获得最多10个元素（实际上将发射4个元素并完成）。
```

#### Cancelling a subscribe() with Its Disposable

所有这些基于lambda的subscribe()的变体都有一个Disposable的返回类型。在这种情况下，一次性接口代表了这样一个事实：通过调用其dispose()方法，订阅可以被取消。

对于Flux或Mono来说，取消是一个信号，表明源应该停止生产元素。然而，它不保证是立即的。有些源可能产生元素的速度非常快，甚至在收到取消指令之前就完成了。

一些围绕一次性的实用程序在一次性类中可用。其中，Disposables.swap()创建了一个Disposable包装器，让你可以原子式地取消和替换一个具体的Disposable。这可能很有用，例如，在UI场景中，当用户点击一个按钮时，你想取消一个请求，并用一个新的请求来替换它。处置包装器本身就可以关闭它。这样做是为了处置当前的具体数值和所有未来尝试的替换。

另一个有趣的工具是Disposables.composite(...)。这种复合可以让你收集多个一次性--例如，与一个服务调用相关的多个飞行中的请求--并在稍后一次性处置所有这些请求。一旦复合的dispose()方法被调用，任何试图添加另一个一次性的尝试都会被立即处置。

#### 一个替代Lambdas的方法,基础用户(BaseSubscriber)

还有一个额外的订阅方法，它更通用，需要一个完整的订阅者，而不是由lambdas组成。为了帮助编写这样一个订阅者，我们提供了一个可扩展的类，叫做BaseSubscriber。

> BaseSubscriber(或它的子类)的实例是一次性使用的，这意味着如果BaseSubscriber被订阅到第二个Publisher，它就会取消对第一个Publisher的订阅。这是因为两次使用一个实例会违反Reactive Streams规则，即订阅者的onNext方法不得被并行调用。因此，只有在调用Publisher#subscribe(Subscriber)时直接声明匿名的实现才行。

现在我们可以实现其中的一个。我们称它为SampleSubscriber。下面的例子显示了如何将它连接到一个Flux上。

```java
SampleSubscriber<Integer> ss = new SampleSubscriber<>();
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(ss);
```

下面的例子显示了SampleSubscriber可以是什么样子，作为BaseSubscriber的一个最小化的实现。

```java
package io.projectreactor.samples;

import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber<T> extends BaseSubscriber<T> {

    public void hookOnSubscribe(Subscription subscription) {
        System.out.println("Subscribed");
        request(1);
    }

    public void hookOnNext(T value) {
        System.out.println(value);
        request(1);
    }
}
```

SampleSubscriber类扩展了BaseSubscriber，BaseSubscriber是Reactor中用户定义的订阅器的推荐抽象类。该类提供了可以被重载的钩子，以调整订阅者的行为。默认情况下，它触发了一个无界请求，其行为与subscribe()完全一样。然而，当你想要一个自定义的请求量时，扩展BaseSubscriber会更有用。

对于一个自定义的请求量，最起码要实现hookOnSubscribe(Subscription)和hookOnNext(T value)，就像我们做的那样。在我们的例子中，hookOnSubscribe方法打印了一条语句到标准输出，并发出了第一个请求。然后hookOnNext方法打印一条语句并执行额外的请求，每次一个请求。

BaseSubscriber还提供了一个requestUnbounded()方法来切换到无界模式（相当于request(Long.MAX_VALUE)），以及一个cancel()方法。

它还有额外的钩子：hookOnComplete、hookOnError、hookOnCancel和hookFinally（当序列终止时总是被调用，终止的类型作为SignalType参数传入）。

> 你几乎肯定要实现hookOnError、hookOnCancel和hookOnComplete方法。你可能还想实现hookFinally方法。SampleSubscriber是执行有界请求的订阅者的绝对最小实现。

#### On Backpressure and Ways to Reshape Requests

在Reactor中实现背压时，消费者压力被传播回源头的方式是向上游发送请求。当前请求的总和有时被称为当前的 "需求"，或 "未决请求"。需求的上限是Long.MAX_VALUE，代表一个无限制的请求（意味着 "尽可能快地生产"--基本上是禁用背压）。

第一个请求来自订阅时的最终订阅者，然而最直接的订阅方式都会立即触发Long.MAX_VALUE的无界请求。
- subscribe()和它的大多数基于lambda的变体（有一个Consumer<Subscription>的除外）
- block()、blockFirst()和blockLast()。
- 对toIterable()或toStream()进行迭代

定制原始请求的最简单方法是用一个重写了hookOnSubscribe方法的BaseSubscriber进行订阅，如下例所示。

```java
Flux.range(1, 10)
    .doOnRequest(r -> System.out.println("request of " + r))
    .subscribe(new BaseSubscriber<Integer>() {
      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
});
```

> 当操纵一个请求时，你必须小心地产生足够的需求以使序列前进，否则你的Flux会被 "卡住"。这就是为什么BaseSubscriber在hookOnSubscribe中默认为一个无界的请求。当重写这个钩子时，你通常应该至少调用一次require。

改变下游需求的运营商
需要记住的一点是，在订购层面表达的需求可以被上游链中的每个操作者重新塑造。一个教科书式的案例是缓冲区(N)操作者。如果它收到一个请求(2)，它被解释为对两个完整的缓冲区的需求。因此，由于缓冲区需要N个元素才能被认为是满的，缓冲区操作符将请求重塑为2 x N。

你可能还注意到，一些运算符有一些变体，接受一个叫做prefetch的int输入参数。这是另一类修改下游请求的运算符。这些通常是处理内部序列的运算符，从每个传入的元素中导出一个Publisher（如flatMap）。

Prefetch是一种调整对这些内部序列提出的初始请求的方法。如果没有指定，这些操作符大多从32的需求开始。

这些运算符通常还实现了一个补给优化。一旦运算器看到75%的预取请求得到满足，它就会从上游重新请求75%的请求。这是一个启发式的优化，使这些运营商主动地预测即将到来的请求。

最后，有几个运算符让你直接调整请求：limitRate和limitRequest。

limitRate(N) 分割下游请求，使它们以较小的批次向上游传播。例如，向limitRate(10)提出的100个请求，最多会导致10个10的请求被传播到上游。请注意，在这种形式下，limitRate实际上实现了前面讨论的补给优化。

该操作符有一个变体，也可以让你调整补给量（在变体中称为lowTide）：limitRate(highTide, lowTide)。选择lowTide为0会导致严格的highTide请求批次，而不是由补给策略进一步返工的批次。

limitRequest(N)，另一方面，将下游请求限定为最大的总需求。如果一个请求没有使总需求量超过N，那么这个特定的请求就会完全向上游传播。在源发出该数量的请求后，limitRequest认为该序列已经完成，向下游发送一个onComplete信号，并取消源。

### 以编程方式创建一个序列

#### 同步 generate

最简单的程序化创建Flux的形式是通过generate方法，它需要一个生成器函数。

这是针对同步和逐一排放的，也就是说，汇是一个SynchronousSink，它的next()方法在每个回调调用中最多只能被调用一次。然后你可以额外地调用error(Throwable)或complete()，但这是可选的。

最有用的变体可能是让你保留一个状态，你可以在水槽的使用中参考这个状态来决定下一步发射什么。然后，生成器函数成为BiFunction<S, SynchronousSink<T>, S>，其中S是状态对象的类型。你必须为初始状态提供一个Supplier泛型S，而你的生成器函数现在在每一轮都会返回一个新的状态。

例如，你可以使用一个int作为状态。

```java
Flux<String> flux = Flux.generate(() -> 0, (state, sink) -> { // 我们提供的初始状态值为0。
    sink.next("3 x " + state + " = " + 3*state); // 我们用状态来选择发射的内容（3的乘法表的一行）。
    if (state == 10) sink.complete(); // 我们也用它来选择何时停止。
    return state + 1; // 我们返回一个新的状态，在下一次调用中使用（除非序列在这次调用中终止了）。
});
```

你也可以使用一个可变的S。例如，上面的例子可以用一个单一的AtomicLong作为状态来重写，在每一轮中对它进行变异。

```java
Flux<String> flux = Flux.generate(
    AtomicLong::new,
    (state, sink) -> {
      long i = state.getAndIncrement();
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state;
});
```

> 如果你的状态对象需要清理一些资源，使用 generate(Supplier < S >, BiFunction, Consumer < S >) 变体来清理最后一个状态实例。

下面的例子使用了包括一个消费者的生成方法。

```java
Flux<String> flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -> {
      long i = state.getAndIncrement();
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state;
    }, (state) -> System.out.println("state: " + state)); // 我们看到最后一个状态值（11）是这个Consumer lambda的输出。
```

如果状态包含数据库连接或其他需要在流程结束时处理的资源，Consumer lambda可以关闭连接或以其他方式处理任何应该在流程结束时完成的任务。

#### 异步和多线程：create

create是一种更高级的程序化创建Flux的形式，它适合于每轮的多次排放，甚至来自多个线程。

它暴露了一个FluxSink，以及它的next、error和complete方法。与Generate相反，它没有一个基于状态的变量。另一方面，它可以在回调中触发多线程的事件。

> create对于连接现有的API和反应式世界非常有用--比如基于监听器的异步API。

> create并不能使你的代码并行化，也不能使它异步化，尽管它可以用于异步API。如果你在create lambda内阻塞，你就会把自己暴露在死锁和类似的副作用中。即使使用了subscribeOn，还有一个注意事项，那就是长期阻塞的create lambda（比如无限循环调用sink.next(t)）可以锁定管道：由于循环饿死了它们应该运行的同一线程，请求将永远不会被执行。使用subscribeOn(Scheduler, false)变量：requestOnSeparateThread = false将使用Scheduler线程进行创建，并且仍然让数据通过在原始线程中执行请求来流动。

想象一下，你使用一个基于监听器的API。它按块处理数据，有两个事件。(1)一个数据块准备好了，(2)处理完成了（终端事件），在MyEventListener接口中表示。

```java
interface MyEventListener<T> {
    void onDataChunk(List<T> chunk);
    void processComplete();
}
```

你可以使用create将其桥接成Flux<T>。

```java
Flux<String> bridge = Flux.create(sink -> {
    myEventProcessor.register(
      new MyEventListener<String>() {

        public void onDataChunk(List<String> chunk) {
          for(String s : chunk) {
            sink.next(s);
          }
        }

        public void processComplete() {
            sink.complete();
        }
    });
});
```

此外，由于create可以连接异步API并管理背压，你可以通过指示OverflowStrategy来细化背压的行为。
- IGNORE 来完全忽略下游的反压请求。当下游队列爆满时，这可能会产生IllegalStateException。
- ERROR 当下游无法跟上时，发出IllegalStateException信号。
- DROP 如果下游没有准备好接收信号，则放弃输入的信号。
- LATEST 以让下游只从上游获得最新的信号。
- BUFFER (默认)来缓冲所有的信号，如果下游跟不上的话。(这做了无界的缓冲，可能导致OutOfMemoryError）。

> Mono也有一个创建发生器。Mono的create的MonoSink不允许多次发射。它将丢弃第一个信号后的所有信号。

#### 异步和单线程的：push

push是介于generate和create之间的一个中间环节，适合处理来自单个生产者的事件。它与create类似，也可以是异步的，可以使用create支持的任何溢出策略来管理背压。然而，每次只有一个生产线程可以调用next、complete或error。

```java
Flux<String> bridge = Flux.push(sink -> {
    myEventProcessor.register(
      new SingleThreadEventListener<String>() { // 通往SingleThreadEventListener API的桥梁。

        public void onDataChunk(List<String> chunk) {
          for(String s : chunk) {
            sink.next(s); // 事件使用下一个来自单个监听器线程的推送到水槽中。
          }
        }

        public void processComplete() {
            sink.complete(); // 完整事件由同一监听器线程生成。
        }

        public void processError(Throwable e) {
            sink.error(e); // 错误事件也从同一个监听器线程中产生。
        }
    });
});
```

##### 一个混合的推/拉模型

大多数Reactor操作者，如create，遵循混合推/拉模型。我们的意思是，尽管大部分的处理是异步的（建议采用推的方式），但也有一个小的拉的成分：request。

消费者从源头拉取数据，也就是说，在第一次请求之前，它不会发出任何东西。只要数据可用，源头就会向消费者推送数据，但要在其请求量的范围内。

请注意，push()和create()都允许设置一个onRequest消费者，以管理请求量，并确保只有在有待处理的请求时才通过sink推送数据。

```java
Flux<String> bridge = Flux.create(sink -> {
    myMessageProcessor.register(
      new MyMessageListener<String>() {

        public void onMessage(List<String> messages) {
          for(String s : messages) {
            sink.next(s); // 其余后来异步到达的信息也被交付。
          }
        }
    });
    sink.onRequest(n -> {
        List<String> messages = myMessageProcessor.getHistory(n); // 在提出请求时轮询消息。
        for(String s : messages) {
           sink.next(s); // 如果立即有消息，就把它们推到水槽。
        }
    });
});
```

##### Cleaning up after push() or create()

两个回调，onDispose和onCancel，在取消或终止时执行任何清理。onDispose可以用来在Flux完成、出错或取消时执行清理。onCancel可以用来在onDispose的清理之前执行任何特定于取消的动作。

```java
Flux<String> bridge = Flux.create(sink -> {
    sink.onRequest(n -> channel.poll(n))
        .onCancel(() -> channel.cancel())
        .onDispose(() -> channel.close())
});
```

#### Handle

处理方法有点不同：它是一个实例方法，意味着它是在一个现有的源上连锁的（就像普通的操作符一样）。它在Mono和Flux中都存在。

它与generate很接近，因为它使用SynchronousSink，并且只允许逐一排放。然而，handle可以被用来从每个源元素中生成一个任意的值，可能会跳过一些元素。通过这种方式，它可以作为map和过滤器的组合。handle的签名如下。

```java
Flux<R> handle(BiConsumer<T, SynchronousSink<R>>);
```

让我们考虑一个例子。反应式流规范不允许序列中出现空值。如果你想执行一个映射，但你想使用一个预先存在的方法作为映射函数，而该方法有时会返回null，怎么办？

例如，下面的方法可以安全地应用于整数的来源。

```java
public String alphabet(int letterNumber) {
    if (letterNumber < 1 || letterNumber > 26) {
        return null;
    }
    int letterIndexAscii = 'A' + letterNumber - 1;
    return "" + (char) letterIndexAscii;
}
```

然后我们可以使用handle来删除任何空值。

```java
Flux<String> alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -> {
        String letter = alphabet(i);
        if (letter != null)
            sink.next(letter);
    });

alphabet.subscribe(System.out::println);
```

### Threading and Schedulers

Reactor，像RxJava一样，可以被认为是并发性的。也就是说，它并不强制执行一个并发模型。相反，它让你这个开发者来指挥。然而，这并不妨碍该库在并发性方面帮助你。

获得一个Flux或Mono并不一定意味着它在一个专门的Thread中运行。相反，大多数运算符会在上一个运算符执行的线程中继续工作。除非指定，最上面的运算符（源）本身是在调用subscribe()的线程中运行的。下面的例子是在一个新的线程中运行一个Mono。

```java
public static void main(String[] args) throws InterruptedException {
  final Mono<String> mono = Mono.just("hello ");

  Thread t = new Thread(() -> mono
      .map(msg -> msg + "thread ")
      .subscribe(v -> System.out.println(v + Thread.currentThread().getName())
      )
  )
  t.start();
  t.join();
}
```

在Reactor中，执行模型和执行地点是由使用的Scheduler决定的。Scheduler的调度职责类似于ExecutorService，但有一个专门的抽象让它做得更多，特别是作为一个时钟，并实现更广泛的实现（测试的虚拟时间、蹦床或即时调度，等等）。

Schedulers类有一些静态方法，可以访问以下执行环境。
- 无执行环境（Schedulers.immediate()）：在处理时，提交的Runnable将被直接执行，有效地在当前线程上运行它们（可以被看作是一个 "空对象 "或无操作的Scheduler）。
- 一个单一的、可重复使用的线程（Schedulers.single()）。请注意，这个方法为所有的调用者重复使用同一个线程，直到Scheduler被处理掉。如果你想要一个每个调用的专用线程，请为每个调用使用Schedulers.newSingle()。
- 一个无界的弹性线程池（Schedulers.elastic()）。随着Schedulers.boundedElastic()的引入，这个不再是首选，因为它有隐藏背压问题和导致过多线程的倾向（见下文）。
- 一个有界限的弹性线程池（Schedulers.boundedElastic()）。和它的前身elastic()一样，它根据需要创建新的工作池，并重新利用闲置的工作池。闲置时间过长（默认为60秒）的工作池也会被处理掉。与elastic()的前身不同，它对可以创建的支持线程的数量有一个上限（默认为CPU核心数×10）。在达到上限后提交的最多100 000个任务会被排队，并在有线程可用时被重新安排（当用延迟调度时，延迟从线程可用时开始）。对于I/O阻塞性工作来说，这是一个更好的选择。Schedulers.boundedElastic()是一种方便的方法，可以给一个阻塞的进程提供自己的线程，这样它就不会占用其他资源。参见 "如何包装一个同步的、阻塞的调用？"，但不会因为新的线程而给系统带来太多压力。
- 一个固定的工作者池，它被调整为并行工作（Schedulers.parallel()）。你有多少个CPU核心，它就创建多少个工作者。

此外，你可以通过使用Schedulers.fromExecutorService(ExecutorService)来从任何预先存在的ExecutorService中创建一个Scheduler。(你也可以从一个执行器中创建一个，尽管不鼓励这样做）。

你也可以通过使用newXXX方法来创建各种调度器类型的新实例。例如，Schedulers.newParallel(yourScheduleName)创建一个名为yourScheduleName的新的并行调度器。

> 虽然boundedElastic是为了帮助处理遗留的阻塞代码，如果它不能避免的话，但single和parallel则不是。因此，使用Reactor阻塞API（block(), blockFirst(), blockLast()（以及在默认的单线和并行调度器中迭代toIterable()或toStream()）会导致抛出IllegalStateException。自定义调度器也可以通过创建实现NonBlocking标记接口的Thread实例来标记为 "仅非阻塞"。

一些操作符默认使用Schedulers中的特定调度器（通常会让你选择提供一个不同的调度器）。例如，调用Flux.interval(Duration.ofMillis(300))工厂方法会产生一个Flux<Long>，它每隔300ms就跳动一次。默认情况下，这是由Schedulers.parallel()启用的。下面一行将Scheduler改为类似于Schedulers.single()的新实例。

```java
Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))
```

Reactor提供了两种在反应式链中切换执行上下文（或调度器）的方法：publishOn和subscribeOn。 两者都需要一个调度器，并让你将执行上下文切换到该调度器。但是publishOn在链中的位置很重要，而subscribeOn的位置则不重要。要理解这个区别，你首先要记住，在你订阅之前什么都不会发生。

在Reactor中，当你使用链式操作符时，你可以根据需要将尽可能多的Flux和Mono实现包在彼此之间。一旦你订阅了，就会创建一个订阅者对象的链，向后（沿着链往上）到第一个发布者。这对你来说是有效的隐藏。你能看到的只是Flux（或Mono）和订阅的外层，但这些中间的操作者特定的订阅者才是真正工作的地方。

有了这些知识，我们就可以仔细看看publishOn和subscribeOn操作者了。

#### he publishOn Method

publishOn的应用方式与其他运营商相同，位于用户链的中间。它从上游获取信号并在下游复制它们，同时在相关的Scheduler的worker上执行回调。因此，它影响到后续操作者的执行位置（直到另一个publishOn被链入），如下所示。
- 将执行环境改为由Scheduler挑选的一个线程。
- 按照规范，onNext的调用是依次进行的，所以这就占用了一个线程。
- 除非他们在特定的Scheduler上工作，否则在PublishOn之后的操作者会继续在同一个线程上执行。

```java
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); // 创建一个由四个线程实例支持的新Scheduler。

final Flux<String> flux = Flux
    .range(1, 2)
    .map(i -> 10 + i) // 第一个map在<5>的匿名线程上运行。
    .publishOn(s) // publishOn将整个序列切换到从<1>中挑选的线程上。
    .map(i -> "value " + i); // 第二个map在<1>的线程上运行。
new Thread(() -> flux.subscribe(System.out::println)); // 这个匿名线程是发生订阅的地方。打印发生在最新的执行上下文上，也就是来自publishOn的那个。
```

#### The subscribeOn Method

subscribeOn适用于订阅过程，当该后向链被构建时。因此，无论你把 subscribeOn 放在链的哪个位置，它总是影响源排放的上下文。然而，这并不影响对publishOn的后续调用的行为--它们仍然为链的后面部分切换执行上下文。
- 改变整个运营商链所订阅的线程。
- 从Scheduler中挑选一个线程

> 实际上，只有链中最早的 subscribeOn 调用才被考虑在内。

```java
Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); // 创建一个由四个线程支持的新Scheduler。

final Flux<String> flux = Flux
    .range(1, 2)
    .map(i -> 10 + i) // first map 在这四条线中的一条上运行
    .subscribeOn(s) // 因为subscribeOn从订阅时间（<5>）开始就切换整个序列。
    .map(i -> "value " + i); // second map 也在同一个线程上运行
new Thread(() -> flux.subscribe(System.out::println)); // 这个匿名线程是最初发生订阅的地方，但subscribeOn立即将其转移到四个调度器线程之一。
```

### Handling Errors

在Reactive Streams中，错误是终端事件。一旦发生错误，它就会停止序列，并沿着操作者链传播到最后一步，即你定义的订阅者和它的onError方法。

这样的错误仍然应该在应用层面上处理。例如，你可以在用户界面中显示一个错误通知，或者在REST端点中发送一个有意义的错误有效载荷。出于这个原因，订阅者的onError方法应该总是被定义。

> 如果没有定义，onError会抛出一个UnsupportedOperationException。你可以用Exceptions.isErrorCallbackNotImplemented方法进一步检测和分流它。

Reactor还提供了替代手段来处理链条中间的错误，作为错误处理运算符。下面的例子展示了如何做到这一点。

```java
Flux.just(1, 2, 0)
    .map(i -> "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example
```

> 在你学习错误处理运算符之前，你必须牢记，反应式序列中的任何错误都是一个终端事件。即使使用了一个错误处理操作符，它也不会让原来的序列继续下去。相反，它将onError信号转换为一个新序列（回退序列）的开始。换句话说，它取代了它的上游的终止序列。

现在我们可以逐一考虑每一种错误处理的手段。在相关的时候，我们将其与命令式编程的尝试模式进行比较。

#### Error Handling Operators

你可能熟悉在try-catch块中处理异常的几种方法。最值得注意的是，这些方法包括以下几种。
- 捕获并返回一个静态默认值。
- 捕捉并执行一个具有后退方法的替代路径。
- 捕获并动态地计算一个回退值。
- 捕捉，包裹成一个BusinessException，并重新抛出。
- 捕获，记录特定的错误信息，并重新抛出。
- 使用finally块来清理资源，或者使用Java 7的 "try-with-resource "结构。

所有这些在Reactor中都有对应的错误处理操作符的形式。在研究这些操作符之前，我们首先要建立一个反应式链和try-catch块之间的平行关系。

当订阅时，链末尾的onError回调就类似于catch块。正如下面的例子所示，在抛出异常的情况下，执行会跳转到catch。

```java
try {
    for (int i = 1; i < 11; i++) {
        String v1 = doSomethingDangerous(i); 
        String v2 = doSecondTransform(v1); 
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); 
}

Flux<String> s = Flux.range(1, 10)
    .map(v -> doSomethingDangerous(v))
    .map(v -> doSecondTransform(v));
s.subscribe(value -> System.out.println("RECEIVED " + value),
            error -> System.err.println("CAUGHT " + error)
);
```

##### Static Fallback Value

```java
try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}

Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");

// 你也可以选择在异常上应用一个谓词来决定是否恢复，如下例所示。
Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -> e.getMessage().equals("boom10"), "recovered10");
```

##### Fallback Method

```java
String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}

Flux.just("key1", "key2")
    .flatMap(k -> callExternalService(k)
        .onErrorResume(e -> getFromCache(k))
    );
```

和onErrorReturn一样，onErrorResume也有一些变体，可以让你根据异常的类别或谓词来过滤哪些异常需要回退。事实上，它需要一个函数，这也让你可以根据遇到的错误选择不同的回退序列。下面的例子展示了如何做到这一点。

```java
Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -> callExternalService(k))
    .onErrorResume(error -> {
        if (error instanceof TimeoutException)
            return getFromCache(k);
        else if (error instanceof UnknownKeyException)
            return registerNewEntry(k, "DEFAULT");
        else
            return Flux.error(error);
    })
);
```

##### Dynamic Fallback Value

即使你没有其他（更安全的）处理数据的方法，你也可能想从你收到的异常中计算出一个回退值。这就相当于 "捕获并动态计算一个回退值"。

例如，如果你的返回类型（MyWrapper）有一个专门用于保持异常的变体（想想Future.complete(T success)和Future.completeExceptionally(Throwable error)），你可以实例化这个保持异常的变体并传递异常。

一个命令式的例子是这样的。

```java
try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}

// 你可以通过使用onErrorResume，以与回退方法解决方案相同的方式反应性地实现这一点，只需一点点模板，如下所示。
erroringFlux.onErrorResume(error -> Mono.just(
        MyWrapper.fromError(error)
));
```

##### Catch and Rethrow

```java
try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}

// 在 "fallback method "的例子中，flatMap里面的最后一行给我们提供了一个提示，可以有反应地实现同样的目的，如下所示。
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    .onErrorResume(original -> Flux.error(
            new BusinessException("oops, SLA exceeded", original))
);
// 然而，有一个更直接的方法可以用onErrorMap达到同样的效果。
Flux.just("timeout1")
    .flatMap(k -> callExternalService(k))
    .onErrorMap(original -> new BusinessException("oops, SLA exceeded", original));
```

##### Log or React on the Side

```java
try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}

LongAdder failureStat = new LongAdder();
Flux<String> flux =
Flux.just("unknown")
    .flatMap(k -> callExternalService(k))
    .doOnError(e -> {
        failureStat.increment();
        log("uh oh, falling back, service failed for key " + k);
    })
);
```

##### Using Resources and the Finally Block

```java
Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}

try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}
```

两者都有其对应的Reactor：doFinally和using。

doFinally是指当序列终止（onComplete或onError）或被取消时，你希望执行的副效应。它给你一个提示，告诉你什么样的终止触发了这个副作用。下面的例子展示了如何使用doFinally。

```java
Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux<String> flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -> stats.startTimer())
    .doFinally(type -> {
        stats.stopTimerAndRecordTiming();
        if (type == SignalType.CANCEL)
          statsCancel.increment();
    }).take(1);
```

另一方面，使用处理的情况是，一个Flux是从一个资源派生出来的，每当进行处理时，必须对该资源进行操作。在下面的例子中，我们将 "try-with-resource "的AutoCloseable接口替换为一次性的。

```java
AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true);
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};
```

现在我们可以对它进行相当于 "try-with-resource "的反应式处理，它看起来像下面这样。

例. 反应式 try-with-resource: using()

```java
Flux<String> flux =
Flux.using(
        () -> disposableInstance,
        disposable -> Flux.just(disposable.toString()),
        Disposable::dispose
);
```

##### Retrying

还有一个关于错误处理的操作符，你可能想在上一节描述的情况下使用它。重试，正如其名称所示，让你重试一个产生错误的序列。

需要记住的是，它是通过重新订阅上游的Flux而工作的。这实际上是一个不同的序列，而原来的那个序列仍然被终止。为了验证这一点，我们可以重新使用前面的例子，附加一个retry(1)来重试一次，而不是使用onErrorReturn。下面的例子显示了如何做。

```java
Flux.interval(Duration.ofMillis(250))
    .map(input -> {
        if (input < 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() // elapsed将每个值与前一个值发出后的持续时间联系起来。
    .subscribe(System.out::println, System.err::println);

Thread.sleep(2100);
```

正如你在前面的例子中所看到的，retry(1)只是重新订阅了一次原始的时间间隔，从0开始重新启动了tick。

有一个更高级的重试版本（称为retryWhen），它使用一个 "同伴 "Flux来告诉一个特定的失败是否应该重试。这个同伴通量是由操作者创建的，但由用户装饰，以便定制重试条件。

伙伴通量是一个通量<RetrySignal>，它被传递给Retry策略/函数，作为retryWhen的唯一参数提供。作为用户，你定义该函数并使其返回一个新的Publisher<?>。Retry类是一个抽象类，但它提供了一个工厂方法，如果你想用一个简单的lambda（Retry.from(Function)）来转换同伴。

- 每当错误发生时（提供重试的可能性），一个RetrySignal就会被发射到同伴的Flux中，这个Flux已经被你的函数装饰过了。在这里有一个Flux，可以看到到目前为止所有的尝试情况。RetrySignal提供了对错误以及相关元数据的访问。
- 如果配套的Flux发出一个值，就会发生重试。
- 如果伴生的Flux完成了，错误被吞噬，重试周期停止，结果序列也完成了。
- 如果伴生的Flux产生了一个错误（e），重试周期就会停止，结果序列就会出现e错误。

前面两种情况的区别是很重要的。简单地完成同伴将有效地吞掉一个错误。考虑以下通过使用retryWhen来模拟retry(3)的方式。

```java
Flux<String> flux = Flux
    .<String>error(new IllegalArgumentException()) // 这不断产生错误，要求重试。
    .doOnError(System.out::println) // 在重试前的doOnError让我们记录并看到所有的失败。
    .retryWhen(Retry.from(companion -> // 重试是由一个非常简单的函数lambda改编的
        companion.take(3))); // 这里，我们认为前三个错误是可以重试的（take(3)），然后放弃。
```

实际上，前面的例子导致了一个空的Flux，但是它成功完成了。由于在同一个Flux上的retry(3)会以最新的错误结束，这个retryWhen的例子与retry(3)不完全相同。

要达到相同的行为需要一些额外的技巧。

```java
AtomicInteger errorCount = new AtomicInteger();
Flux<String> flux =
        Flux.<String>error(new IllegalArgumentException())
                .doOnError(e -> errorCount.incrementAndGet())
                .retryWhen(Retry.from(companion ->
                        companion.map(rs -> {
                            if (rs.totalRetries() < 3) return rs.totalRetries();
                            else throw Exceptions.propagate(rs.failure());
                        })
                ));
```

核心提供的Retry帮助器，RetrySpec和RetryBackoffSpec，都允许高级定制，如。
- 为可以触发重试的异常设置过滤器（Predicate）。
- 通过modifyErrorFilter(Function)修改之前设置的过滤器
- 围绕重试触发器触发一个像日志一样的副作用（即在延迟之前和之后进行反击），只要重试被验证（doBeforeRetry()和doAfterRetry()是相加的）。
- 在重试触发器周围触发一个异步的Mono<Void>，这允许在基本延迟的基础上增加异步行为，但因此进一步延迟触发（doBeforeRetryAsync和doAfterRetryAsync是相加的）。
- 通过onRetryExhaustedThrow(BiFunction)，在达到最大尝试次数的情况下定制异常。默认情况下，使用Exceptions.retryExhausted(...)，这可以用Exceptions.isRetryExhausted(Throwable)来区分。
- 激活对瞬时错误的处理。

Retry规范中的瞬时错误处理使用了RetrySignal#totalRetriesInARow()：检查是否重试并计算重试延迟，所使用的索引是一个替代索引，每次onNext被发出时都被重置为0。这样做的后果是，如果一个重新订阅的源在再次失败之前产生了一些数据，那么之前的失败就不会被计入重试的最大次数。在指数退避策略的情况下，这也意味着下一次尝试将回到使用最小持续时间退避而不是更长的时间。这对看到零星错误（或瞬时错误）的长寿源来说特别有用，在这种情况下，每一个突发事件都应该用它自己的退避来重试。

```java
AtomicInteger errorCount = new AtomicInteger();
AtomicInteger transientHelper = new AtomicInteger();
Flux<Integer> transientFlux = Flux.<Integer>generate(sink -> {
    int i = transientHelper.getAndIncrement();
    if (i == 10) {
        sink.next(i);
        sink.complete();
    }
    else if (i % 3 == 0) {
        sink.next(i);
    }
    else {
        sink.error(new IllegalStateException("Transient error at " + i));
    }
})
        .doOnError(e -> errorCount.incrementAndGet());

transientFlux.retryWhen(Retry.max(2).transientErrors(true))
             .blockLast();
assertThat(errorCount).hasValue(6);
```

### Processors and Sinks

处理器是一种特殊的发布者，同时也是一个订阅者。它们最初是作为中间步骤的可能代表，然后可以在Reactive Streams实现之间共享。但在Reactor中，这种步骤是由Publisher的操作者来表示的。

第一次接触处理器时，一个常见的错误是直接从订阅者接口调用暴露的onNext、onComplete和onError方法。

这样的手动调用应该谨慎进行，特别是关于与Reactive Streams规范有关的外部同步调用。处理器实际上可能没什么用，除非遇到需要传递订阅者的基于Reactive Streams的API，而不是暴露一个发布者。

汇通常是一个更好的选择。在Reactor中，Sink是一个允许安全手动触发信号的类。它既可以与订阅者相关联（来自运营商内部），也可以完全独立。