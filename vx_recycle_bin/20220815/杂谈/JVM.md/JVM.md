# JVM

## 什么时候会触发Full GC?

1. 晋升到老年代的对象大于老年代的剩余空间。
2. 老年代的内存使用率达到了一定阈值（可通过参数调整）。
3. Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值。
4. 在执行minor gc的时候进行的一系列检查
5. 执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。
6. 如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。
7. 如果小于了，JVM会检查是否开启了空间分配担保机制
8. 如果没有开启则直接执行Full GC。
9. 如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小
10. 如果小于则执行Full GC。如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC
使用了大对象 //大对象会直接进入老年代。比如：一次加载过多数据到内存（比如SQL查询未分页），导致大对象进入老年代。
11. -XX:PretenureSizeThreshold参数控制，若对象大小大于此值，就会绕过新生代, 直接在老年代中分配。
12. 程序执行了System.gc() //建议jvm执行FGC，并不一定会执行
13. 执行了jmap -histo:live pid命令
14. 其他
    1. 上一次GC之后Heap的各域分配策略动态变化
    2. RMI等的定时触发
    3. YGC时的悲观策略