> 设计模式

创建型

1. Factory Method 工厂方法: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化
2. Abstract Factory 抽象工厂: 提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类
3. Builder 构建器: 将一个复杂对象构建与它的表示分离
4. Prototype 原型: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象
5. Singletion 单例: 保证一个类仅有一个实例，并提供一个访问它的全局访问点

结构型

1. Adapter 适配器: 将一个类的接口转换成客户希望的的另外一个接口，是的本由于接口不兼容而不能一起工作的那些类可以一起工作
2. Bridge 桥接: 将抽象部分与它的实现分离，使它们都可以独立的变化
3. Composite 组合: 将对象组合成树状结构以表示“部分-整体”的层次结构，使得客户对单个对象和复合对象的使用具有一致性
4. Decorator 装饰器: 动态的给一个对象添加一些额外的职责。比生成子类还要灵活。
5. Facade 外观: 为子系统中的一组接口提供一致的界面，定义了一个高层的接口这个接口使得这一子系统更加容易使用
6. Flyweight 享元: 通过共享技术有效的支持大量细粒度的对象
7. Proxy 代理: 为其他对象提供一个代理以控制这个对象的访问

行为型

1. Interpreter 解释器: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子
2. Template Method 模板方法: 定义一个操作中算法的骨架，而将一些步骤延迟到子类中
3. Chain of Responsibility 责任链: 使得多个对象都可以由机会处理这个请求。将这些对象连成一条链并沿着这条链传递该请求直到有一个对象去处理返回
4. Command 命令: 将一个请求封装为一个对象，使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志并支持取消操作
5. Iterator 迭代器: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示
6. Mediator 中介者: 用一个中介者对象来封装一系列的对象交互，中介者使各个对象不需要显示的相互引用，从而使得其耦合松散，而且可以独立的改变它们之间的交互
7. Memento 备忘录: 不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到保存的状态。
8. Observer 观察者: 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖与它的对象都得到通知并自动刷新
9. State 状态: 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类
10. Strategy 策略: 定义一系列算法把它们封装起来并且可以使得它们可互相替换，使得算法的变化可独立
11. Visitor 访问者: 表示一个作用于某对象结构中的各元素操作，使得你可以在不改变各元素的类的前提下定义作用于这些元素的新操作