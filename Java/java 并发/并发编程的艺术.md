# 并发编程的艺术

JMM
编译器优化重排序 通过javac编译
	编译器在不改变单线程程序语义的前提下，可以重新安排语句的顺序
指令级并行的重排序
	现代处理器采用了指令级并行技术，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
内存系统的重排序
	由于处理器使用缓存和读、写缓冲区，这使得加载和存储操作看上去可能是在乱序执行
	
关于处理器重排序JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。
JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

内存屏障 如何记忆
	load 读取 store 写 重排序就行：读写、读读、写写、写读
	loadload barriers
	storestore barriers
	lodastore barriers
	storeloda barriers

as-if-serial语义
	不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。
happens-before 多线程场景
	JMM最核心的概念。用来保障内存可见性。
	
	与程序员相关的happens-before规则如下
		1.程序顺序规则: 一个线程忠的每个操作,happens-before于该线程中的任意后续操作.
		2.监视器锁规则: 对于一个锁的解锁,happens-before于随后对于这个锁的加锁.
		3.volatile变量规则: 对于一个volatile变量的写,happens-before于任意后续对这个volatile变量的读.
		4.传递性: 如果a happens-before b且b happens-before c那么a happens-before c.
		5.start规则: 如果线程a执行操作ThreadB.start()启动b线程,那么A线程的ThreadB.start()操作happens-before于线程b中的任意操作.
		6.join规则: 如果线程a执行操作ThreadB.join()并成功返回,那么线程b中的任意操作happens-before于线程a从ThreadB.join()操作成功返回.
	两个操作之间具有happens-before关系,并不意味着前一个操作必须要在后一个操作之前执行.happens-before仅仅要求前一个操作执行的结果对后一个操作可见,且前一个操作按顺序在第二个操作之前.