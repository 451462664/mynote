# Elasticsearch

## Elasticsearch 是什么？

Elastic Stack 包括 Elasticsearch、Kabana、Beats 和 Logstash 也称为 Elastic Stack.

Elasticsearch 在其中是核心，是一个分布式、Restful 风格的搜索和数据分析引擎，能够解决不断涌出的各种用例。简称 ES，ES 是一个`开源的高扩展的分布式全文搜索引擎`它可以近乎实时的存储、检索数据.

## Elasticsearch 入门

### Elasticsearch 安装

#### 下载软件

Elasticsearch 官网地址 http://www.elastic.co/cn/

Elasticsearch 版本选择 7.13.4

```shell
# Elasticsearch 目录
Elasticsearch
	-bin 可执行脚本文件
		-elasticsearch.bat 文件来启动，注意 9300 端口为 Elasticsearch 集群间组件的通信端口，9200 端口为浏览器访问的 Restful 端口.
	-config 配置文件
	-jdk 内置 java 环境一般不使用内置的
	-lib 内置类库
	-logs 日志文件
	-modules 模块
	-plugins  插件
```

### 客户端安装

如果直接通过浏览器向 Elasticsearch 服务器发送请求，那么需要在发送的请求中包含 HTTP 标准的方法，而 HTTP 的大部分特性且仅支持 GET 和 POST 方法。所以为了能方便地进行客户端的访问，可以使用 postman 软件.

### Elasticsearch 数据格式

Elasticsearch: Index 索引 -> Type 类型 -> Document 文档 -> Fields 字段.后面 Type 这个概念被废弃.

### Elasticsearch 操作

#### 索引操作

```shell
# 创建索引
向 ES 服务器发送 PUT 请求`http://local:9200/shopping`创建一个 shopping 的索引.
PUT http://localhost:9200/shopping
# 查询索引
GET http://localhost:9200/shopping
# 删除索引
DELETE http://localhost:9200/shopping
```

#### 文档操作

```shell
#  创建文档
POST http://localhost:9200/shopping/_doc
{
	"title": "小米手机",
	"category": "小米",
	"images": "http://gulixueyuan.com/xm.jpg",
	"price": 3999.00
}
# 可以指定 id 在 _doc 后面可以指定
POST http://localhost:9200/shopping/_doc/1001

# 查询文档
查询指定id数据 GET http://localhost:9200/shopping/_doc/1001
查询全部数据 GET http://localhost:9200/shopping/_search

# 修改文档又分为完全覆盖性修改和局部修改
完全覆盖性修改
PUT http://localhost:9200/shopping/_doc/1001
POST http://localhost:9200/shopping/_doc
{
	"title": "小米手机",
	"category": "小米",
	"images": "http://gulixueyuan.com/xm.jpg",
	"price": 4999.00
}
局部数据修改
POST http://localhost:9200/shopping/_update/1001
{
	"doc": {
		"images": "http://gulixueyuan.com/xm.jpg",
		"price": 4999.00
	}
}

# 删除文档
DELETE http://localhost:9200/shopping/_doc/1001
```

#### 条件查询 & 分页查询 & 查询排序

```shell
# 条件查询
GET http://localhost:9200/shopping/_search?q=categroy:小米
POST http://localhost:9200/shopping/_search
{
	"query": {
		"match": {
			"category": "小米"
		}
	}
}

# 分页查询
POST http://localhost:9200/shopping/_search
{
	"query": {
		"match": {
		
		}
	},
	"from": 0,
	"size": 10,
	"_source": ["title"], // 指定显示字段
	"sort": {
		"price": {
			"order": "desc" // 针对某个字段排序
		}
	}
}
```

#### 条件查询 & 范围查询

```shell
# 条件查询和范围查询
POST http://localhost:9200/shopping/_search
{
	"query": {
		"bool": { // 表示条件的意思
			"must": [ // 类似于 and, "should" 类似于 or
				{
					"match": {
						"category": "小米"
					}
				},
				{
					"match": {
						"price": 1999.00
					}
				}
			]
		},
		"filter": {
			"range": {
				"price": {
					"gt": 3000.00,
					"lt": 6000.00
				}
			}
		}
	}
}
```

#### 全文检索 & 完全匹配 & 高亮查询

```shell
POST http://localhost:9200/shopping/_search
{
	"query": {
		"match_phrase": { // "match_phrase" 完全匹配 "match" 全文检索基于分词器
			"category": "小米"
		}
	},
	"highlight": { // 进行指定字段高量显示
		"fields": {
			"category": {
			
			}
		}
	}
}
```

#### 聚合查询

```shell
POST http://localhost:9200/shopping/_search
{
	"aggs": { // 聚合操作
		"price_group": { // 名称，随意起名
			"terms": { // 分组操作 "avg" 平均值
				"field": "price" // 分组字段
			}
		}
	}
}
```

### 映射关系

```shell
首先创建一个索引 PUT http://localhost:9200/user
设置 user 索引的映射关系 PUT http://localhost:9200/user/_mapping
{
	"properties": {
		"name": {
			"type": "text" // "text" 表示可以被分词
			"index": true
		},
		"sex": {
			"type": "keyword", // "keyword" 表示不可以被分词
			"index": true
		},
		"tel": {
			"type": "keyword",
			"index": false // 不能被当作检索条件查询
		}
	}
}
```

### Java API 操作

Elasticsearch 软件是由 Java 语言开发的，所以也可以通过 Java API 的方式对 Elasticsearch 服务进行访问.

```xml
<!-- 高版本的 ES 使用下面这个jar包来引入依赖  -->
<dependency>
	<groupId>org.elasticsearch.client</groupId>
    <artifacId>elasticsearch-rest-hight-level-client</artifacId>
    <version>7.8.0</version>
</dependency>
```

```java
public class ESTest_Client {
    public static void main(String[] args) throws Exception {
        // 创建 ES 客户端
        RestHighLevelClient client = new RestHightLevelClient(RestClient.builder(new HttpHost("localhost", 9200, "http")));
        // 需要关闭连接
        client.close();
    }
}
```

#### 索引操作

```java
// 创建索引
CreateIndexResponse response = client.indices().create(new CreateIndexRequest("user"), RequestOptions.DEFAULT);
// 响应状态
boolean acknowledged = response.isAcknowledged();
// 索引查询
GetIndexResponse response = client.indices().get(new GetIndexRequest("user"), RequestOption.DEFAULT);
// 索引删除
client.indices().delete(new DeleteIndexRequest("user"), RequestOption.DEFAULT);
```

#### 文档操作

```java
// 新增文档
IndexRequest request = new IndexRequest();
request.index("index").id("1001");

User user = new User();
user.setName("zhangsan");
request.source(JSON.toJSONString(user), XContentType.JSON);

client.index(request, RequestOption.DEFAULT);

// 更新文档
UpdateRequest request = new UpdateRequest();
request.index("user").id("1001");
request.doc(XContentType.JSON, "name", "lisi");
client.update(request, RequestOption.DEFAULT);

// 查询
GetRequest request = new GetRequest();
request.index("user").id("1001");
GetResponse response = client.get(request, RequestOption.DEFAULT);
System.out.println(response.getSourceAsString());

// 删除
DeleteRequest request = new DeleteRequest();
request.index("user").id("1001");
client.delete(request, RequestOption.DEFAULT);

// 批量新增
BulkRequest request = new BulkRequest();
request.add(new IndexRequest().index().id().source());
client.bulk(request, RequestOption.DEFAULT);

// 批量删除
BulkRequest request = new BulkRequest();
request.add(new DeleteRequest().index().id());
client.bulk(request, RequestOption.DEFAULT);
```

#### 查询操作

```java
// 查询索引中全部的数据
SearchRequest request = new SearchRequest();
request.indices("user");
request.source(new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()))

SearchResponse response = client.search(requst, RequestOption.DEFAULT);
System.out.println(response.getHis() + ", " + response.getTotalHits);
for (SearchHit hit : response.getHits()) {
    System.out.println(hit.getSourceAsString());
}

// 条件查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.termQuery("name", "lisi"));
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 分页查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());
builder.from(0).size(10);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 排序查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());
builder.sort("age", SortOrder.DESC);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 过滤字段
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery());
// 第一个参数包含某些字段，第二个参数排除某些字段
builder.fatchSource({"name"}, {"age"});
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 组合查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder();
BoolQueryBuilder boolQuerybuilder = QueryBuilders.boolQuery();
boolQuerybuilder.must(QueryBuilders.matchQuery("name", "zhangsan"));
boolQuerybuilder.must(QueryBuilders.matchQuery("sex", "nan"));
builder.query(boolQuerybuilder);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 范围查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder();
RangeQueryBuilder rangeQuerybuilder = QueryBuilders.rangeQuery("age");
rangeQuerybuilder.gte(30);
rangeQuerybuilder.lte(40);
builder.query(rangeQuerybuilder);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

//聚合查询
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder();
AggregationBuilder aggrBuilder = AggregationBuilder.max("maxAge").field("age");
builder.aggregation(aggrBuilder);
builder.query(aggrBuilder);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);

// 分组
SearchRequest request = new SearchRequest();
request.indices("user");
SearchSourceBuilder builder = new SearchSourceBuilder();
AggregationBuilder aggrBuilder = AggregationBuilder.terms("ageGroup").field("age");
builder.aggregation(aggrBuilder);
builder.query(aggrBuilder);
request.source(builder);
SearchResponse response = client.search(requst, RequestOption.DEFAULT);
```

## Elasticsearch 环境

### 相关概念

#### 单机 & 集群

单台 Elasticsearch 服务器提供服务，往往都有最大的负载能力，超过这个阈值，服务器性能就会大大降低甚至不可用，所以生产环境中，一般都是运行在指定服务器集群中。

除了负载能力，单点服务器也存在其他问题:

1. 单台机器存储容量有限
2. 单服务器容易出现单点故障，无法实现高可用
3. 单服务的并发能力有限

##### 集群 Cluster

一个集群就是由一个或多个服务器节点组织在一起，共同持有整个的数据，并一起提供索引和搜索功能。一个 Elasticsearch 集群有一个唯一的名字标识，这个名字默认就是 "elasticsearch".

##### 节点 Node

集群中包含很多服务器，一个节点就是其中的一个服务器。作为集群的一部分，它存储数据，参与集群的索引和搜索功能。

一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于 Elasticsearch 集群中的哪些节点。

一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做 "elasticsearch"的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假设它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做"elasticsearch"的集群中.

#### windows 配置集群

创建一个 elasticsearch-cluster 文件夹，将下载的 elasticsearch 复制到 cluster 文件夹下.

保证是一个新的 elasticsearch 文件，删除 data 文件和清空 logs 文件夹.

打开 elasticsearch.yml 文件进行配置.