> 2021年5月27日

安装环境，并从 git 远程仓库拉取项目，主要分为两个项目。

1. faw-smart-team 这个项目目前看了代码是给前端页面展示查询报表数据使用。
2. smartlink-route-monitor 这个项目目前是使用 flink 拉去 kafka topic 中的数据来进行处理。

明天需要做的

1. 连接上数据库理清楚表结构之间的逻辑、表字段的解释。
2. 搞清楚 smartlink-route-monitor 中的代码逻辑。

> 2021年5月28日

请IT叶工帮忙搞定网络，链接上 MySQL。

1. 并且分了一个新需求启动 job 拉取对应车队的告警信息下发给外围系统。包含超时停车、超速警报、油耗异常、加油异常。设计到车辆主数据表、车队主数据表、告警消息表、告警类型表。
2. 熟悉了下 flink 大致能看懂 smartlink-route-monitor 中的代码逻辑。

周末需要做的

1. flink 体系学习，深入了解下。着重了解下窗口，还有一些 flink 的架构关系。
2. 学习 springboot 怎么整合 kafka 并使用。

> 2021年5月31日

1. 车辆报警信息下发给外围系统逻辑代码编写，需要确认下发送报文的字段还有 kafka 对应的配置信息。
2. 帮助同事分担解决测试中出现的问题。

上周遗留

1. flink 接下来需要看看对应 api 的编写，运行时架构还是不太明白 jobmanager、taskmanager、solt 这些概念。
2. springboot 整合 kafka 大致看了一下。

> 2021年6月1日

1. 主要还是分担同事测试中遇到的问题单。

遗留问题

1. flink 对应 api 编写目前还在看，争取这周看完。
2. springboot 整合 kafka 到时候结合芋道源码中的整合一下。

> 2021年6月2日

1. 解决测试中的问题。更加具体的了解了一些表的结构和关系。
2. 明天需要确认车辆主数据导入中三个字段是从哪里取值。
3. 今天对 flink 的 source、sink 使用进行实践了一下。

遗留问题

停车超时问题明天 debug 看一下。

> 2021年6月3日

今天最大的收获就是终于解决了停车超时的问题单，并且了解了 flink 接口的基础生命周期，但是还有不明白的地方就是 flink 对于 state 的操作等。对于流处理还是有点不理解。

明天需要做: 看一下 flink 的 checkpoint 为什么没生效。

> 2021年6月7日

因为6月4日工作实在想不起来了，这真是不应该。下次一定要记得每天记录。

1. 上周遗留问题是 flink checkpoint 不生效，怀疑是没有开启导致的。需要调用 env.enableCheckpointing(); 这个方法来开启，因为默认 flink 是不开启的。
2. 熟悉了一下接下来版本需要修改的 flink 功能，最后有点公式没有太明白。
3. 协助测试解决了一下 UAT 环境的测试问题。

明日计划

1. 需要启用 ELT 程序来跑一下 UAT 环境的功能。

> 2021年6月8日

1. 义乌接口业务逻辑开发完成，明天自测一下。
2. ELT 程序执行 UAT 跑数据完成。
3. 对地图返回 path 代码问题查看，确认问题所在，经和前端约定后确定修改方案。

明日计划

1. 义乌接口限流功能开发。
2. path 地图功能修改问题。

> 2021年6月9日

1. 义乌德翔数据转发功能联调。
2. UAT 环境解决测试中出现的问题。
3. PC 端 Excel 导入线路后端处理存储结构修改和前端解析保持一致。

今天也熟悉了一下中值滤波、MySQL 多表 JOIN 的执行流程。

明日计划

1. 义乌德翔数据转发功能限流。
2. 对今日评审功能进行熟悉。

> 2021年6月10日

1. 限流 API 实现开发。
2. 参加需求原型会议。

> 2021年6月15日

1.熟悉车辆基础数据 tid 和 adas id 的关系。熟悉车辆全图监控需求的逻辑，并且进行修改。

2.对超时停车 flink 逻辑进行新需求改动思考。目前已有初步修改方案后面会改一版看看。

> 2021年6月16日

1. 对车辆全图监控页面接口需求进行开发，并对现有 truck/tree 接口进行一步优化，查询车辆位置云信息时不再另外查一次数据库封装请求参数信息。应该还有优化的点比如多线程去获取数据来提高并发速度。
2. 对 xxl-job 一些失败任务进行原因排查【未完成】主要堵塞在没有 xxl-job 的日志没有找到，找到的日志日期知道今年四月份，如果能有任务执行日志那么会排查的顺利一点。
3. 对超时停车 flink 逻辑继续进一步了解。对 redis 中获取到的值作为广播去分发到各个算子的分区。
4. 对车辆全图监控左边车辆数中的车辆展示 tbox、adas 等区别准备 SQL 语句，后面会直接在生产操作。

遗留问题，后面有时间会继续看

1. xxl-job 执行失败的问题。

> 2021年6月17日

1. 对车辆全图监控接口进行联调，对于车辆状态的问题进行查看代码。
    1. 我们内部系统 monitor 调用位置云接口后对状态进行了封装、team-core 对状态进行了二次封装。
    2. 没有 gps 上传时间，就认为没有安装设备。行驶：末次上报时间据当前<5分，停止：5分钟<=末次上报时间据当前<24小时。上面情况都没有 就是离线。
2. 车辆告警超时停车导出车速>0问题，经排查发现是业务场景中正常的状况。离线状态下确实可能存在车速>0的情况。所以这个问题经姚金辉沟通认为正常。
3. xxl-job 定时任务问题排查
    1. oilChangeHandler 报错。经排查发现 catch 中没有将 exception 打印出来。怀疑可能是网路请求或者是参数封装时报错，解决方案：打印出具体异常的日志、发生异常直接返回空对象。
    2. oilChangeCancelHandler 报错。经排查发现是请求位置云的时候 oilValue 字段为 null.解决方案过滤出异常的数据。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. 上线的义乌数据转发接口积分油耗缺少值需要加上。

> 2021年6月18日

1. 车辆全图监控小卡片功能开发。
2. 油量检测问题定位，对 flink 数据有疑问可以去服务器将日志拉取下来看。对于检测的 flink 代码逻辑理解更多了。下周实践来试一试。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. 上线的义乌数据转发接口积分油耗缺少值需要加上。
3. 两个 job 的报错问题需要处理。
4. 油量检测的 stream 需要增加 filter 时间过滤。

> 2021年6月21日

1. 风险事件之类的报表功能增加司机字段并展示。
2. 下午熟悉需求，并且将对应的接口请求参数和输出参数都设置好，后期直接回顾一下就可以直接写代码了。
3. 上线的义乌数据转发接口积分油耗缺少值修复。
4. 两个 job 的报错问题修复。

遗留问题

xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年6月22日

1. 对取消油耗异常的定时任务需求了解，发现了当前时间和需求不对。因为是取告警结束时间后的2小时轨迹点数据，代码中是告警开始时间。
2. 车辆摄像头渠道设置，理解需求，并且建立渠道表，车辆基础数据表也加入新字段 channel_id。
3. 整合 mybatis generator 使用生成表对应对象。

今日计划

1. 车辆摄像头渠道设置编码完成。
2. redis 设置 token 后门编码完成自测通过。

> 2021年6月23日

1. 车辆摄像头渠道编码完成，涉及到车辆基础数据编辑、车辆全图监控返回、实时跟踪返回、编辑查看返回。
2. redis 设置 token 后门编码完成。
3. 查询车辆全图监控车辆数与车辆基础数据车数量差距，原因是车辆树只返回 tid 不位空的数据所以导致了差距。

> 2021年6月24日

1. 车队服务号权限优化代码开发完成。
2. 车辆油箱数据定时任务逻辑了解。
3. MySQL 书籍学习一些。

明日计划

完成风险事件需求。

> 2021年6月25日

1. 完成风险事件开发，开发了三分之一。

遗留问题

xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年6月28日

1. 完成风险事件开发，页面展示逻辑已经全部完成。
2. feign 整合到 team-core 项目中，作为消费者必须使用 @EnableFeignClients(basePackages = "com.smartlink.driver.fds.api.provider.feign") 注解。
    1. org.springframework.cloud.openfeign.FeignClientsRegistrar 用来解析 feign 接口并且获取代理类的逻辑，需要仔细看看。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. 数据源需要增加司机获取的逻辑。

> 2021年6月29日

1. 报警&风险-增加司机展示及筛选，前端联调。
2. 解决局域网内 ping 不同本机的情况
    1. 首先网络类型改成专用，公用默认是不允许 ping 通的。
    2. 其次需要关闭防火墙。

> 2021年6月30日

> 2021年7月1日

1. 为车队管理加入 nacos 做项目整合。解决期间出现的问题，发现是沈阳那边 nacos 部署有问题。最后整合到 team-core 项目中。
2. 对开发的功能进行自测并修改问题，实时风险事件详细中，不仅要在主记录返回司机信息还需要在风险明细中返回。
3. monitor-safety 风险事件云中，拿到最新司机人脸识别接口对提供获取司机人脸信息接口逻辑进行完善。

遗留问题

1. 自测。
2. 进行 nacos 细节完善。
3. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年7月2日

1. 对测试用例在测试环境进行冒烟自测。
2. nacos 配置进行完善完毕。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年7月5日

1. 功能进行转测，解决停车超时和超速报警结束完成的 update SQL 异常，后面需要注意参数字段是否在 SQL 中存在。
2. 定位生产油耗异常小数精度问题。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. nacos 依赖转为 clound。

> 2021年7月6日

1. 对转测功能途中出现的问题进行解决。
2. cloud nacos 替换 boot nacos，中发现 cloud 中还有一个 bootstrapContext 优先于 applicationContext 加载属于父环境，但是两个共享环境变量，所以 nacos 配置文件能预加载。应用直接使用 @Value 注解即可获取到配置信息。后面可以深入了解一下。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. flink 代码异常恢复。

> 2021年7月7日

1. 配合测试解决途中产生的问题。[1012941、1012977]。
2. flink 代码故障恢复开发。

> 2021年7月9日

1. 配合其他系统同事查询模拟终端问题，结果是测试环境ip 214不稳定。
2. flink checkPoint 任务异常重启故障恢复功能进行自测。

> 2021年7月12日

1. 配合测试解决测试途中出现的问题。

> 2021年7月14日

对 flink 进行 savePoint 进行启动加载，需要在任务停止前需要手动进行 savePoint 备份，然后在页面启动 job 的时候指定 savePoint Path 进行启动加载。

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。
2. 是否可以 flink 进行自动 savePoint 备份。savePoint 为什么要指定算子 uid。

> 2021年7月16日

1. 处理 UAT 环境 flink 启动失败问题。报错异常为 kafka 和 flink solt 不匹配，具体为什么找运维看了 kafka 一切正常，后面发现了 flink 报错空间不足。清理空间后发现可以正常启动。
2. flink savePoint 备份需要指定算子 uid，因为再后续升级中可能对算子进行修改，这样的话不指定 uid 可能丢失处理状态。

> 2021年7月19日

1. 处理 flink checkpoint、savePoint 保存至 hdfs，期间出现了保存 savepoint 时 flink 不支持，需要下载 flink 版本对应的 hadoop.jar 包。因为目前 flink 已经到达 1.13 所以官网上找不到对应的 jar。所以目前使用了 `flink-shaded-hadoop-2-uber-2.7.5-7.0.jar`
    1. ![image-20210720114014088](D:\Typora\images\image-20210720114014088.png)
2. 配合测试解决 UAT 环境出现的问题，将 excel 导出功能增加忽略注解，这样就不用导出 DTO 必须和 execl 列数量对应了，可以增加属性来处理。后面可以选择优化顺序根据顺序来处理。

> 2021年7月20日

1. 为上线做准备，上线中出现的问题：
    1. 运维在发布 flink 包时，发布的不是最新的导致包上去写 checkpoint 不是 hdfs 的地址。`后面如果需要使用 hdfs 的地址保存文件，必须让运维提前在环境上为我们的路径赋予权限`这次我们的生产地址权限是 `/monitor/flink`.
    2. 如果有风险的事情一定要提前先说.这次刷 c_base_info 表属于有风险的操作.还好狗屎运没有曝出太多的问题.

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年7月21~23日

都是查询生产问题和了解安全分析报表需求逻辑。

> 2021年7月26~29日

主要进行安全分析报告，定时任务持久化数据的功能开发，对于特定日期、特定机构也支持。没有忒的那个日期特定机构，就默认持久化昨天的所有机构。

由于机构下车辆比较多，调用位置云接口会很慢，所以使用了多线程去调用位置云接口。进行了自测，时间从2小时缩短到了10分钟左右。

> 2021年7月30日

主要对于 flink 集群另外两个机器宕机问题处理，分析 flink 日志后发现没有什么可用的线索来定位是否导致宕机。后面是否可以将日志级别降低到 DEBUG 这样日志详细一点，到后面如果在出现再进行具体分析。

对于宕机的 job 通过让运维 savepoint 来备份和启动，目前启动正常，运行正常。

对于超速告警有一个消息延时问题，可能导致提前告警结束，但是 onTimer 还没有执行，因为超速告警的阈值是 1 分钟，flink 接收到的消息可能再 onTimer 之前。所以后面将删除定时器的代码也放在告警结束的时候。

遗留问题

1. flink 为什么会宕机。
2. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年8月2~5日

进行安全分析报告开发，其中整合了 RxJava2 来异步从处理查询和返回。因为内部 RxJava2 中对于线程的管理比较成熟，所以省去了自己编写多线程编程的繁琐程序。

下面先记录一下怎么整合到 springmvc.

```java
/**
 * 1、首先需要声明一个类来实现 WebMvcConfigurer
 * 2、需要重新 addReturnValueHandlers 方法声明自己的 returnValueHandler
 */
@Configuration
public class RxJavaConfig implements WebMvcConfigurer {
    @Override
    public void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {
        handlers.add(new ObservableReturnValueHandler());
        handlers.add(new SingleReturnValueHandler());
    }
}
  
```

因为 RxJava2 发射元素会有两种类型 Single、Observable.所以需要定义两个 ReturnValueHandler.

```java
/**
     * 返回单个值处理 handler
     */
public static class SingleReturnValueHandler implements
    AsyncHandlerMethodReturnValueHandler {

    @Override
    public boolean isAsyncReturnValue(Object o, MethodParameter methodParameter) {
        return null != o && supportsReturnType(methodParameter);
    }

    @Override
    public boolean supportsReturnType(MethodParameter methodParameter) {
        return Single.class.isAssignableFrom(methodParameter.getParameterType());
    }

    @Override
    public void handleReturnValue(Object o, MethodParameter methodParameter,
                                  ModelAndViewContainer mavContainer, NativeWebRequest nativeWebRequest)
        throws Exception {

        if (!(o instanceof Single)) {
            mavContainer.setRequestHandled(true);
            return;
        }

        Single single = Single.class.cast(o);
        WebAsyncUtils.getAsyncManager(nativeWebRequest)
            .startDeferredResultProcessing(new SingleAdapter(single), mavContainer);
    }
}

@Slf4j
public static class SingleAdapter<T> extends DeferredResult<Response<T>> {
    public SingleAdapter(Single<T> single) {
        Disposable subscribe = single
            .subscribe(d -> setResult(ResponseHelper.createSuccessResponse(d)), throwable -> {
                if (log.isInfoEnabled()) {
                    log.error("RxJava Single业务处理失败.", throwable);
                }
            });
        subscribe.dispose();
    }
}

/**
     * 返回多个值 handler
     */
public static class ObservableReturnValueHandler implements
    AsyncHandlerMethodReturnValueHandler {

    @Override
    public boolean isAsyncReturnValue(Object o, MethodParameter methodParameter) {
        return null != o && supportsReturnType(methodParameter);
    }

    @Override
    public boolean supportsReturnType(MethodParameter methodParameter) {
        return Observable.class.isAssignableFrom(methodParameter.getParameterType());
    }

    @Override
    public void handleReturnValue(Object o, MethodParameter methodParameter,
                                  ModelAndViewContainer mavContainer, NativeWebRequest nativeWebRequest)
        throws Exception {

        if (!(o instanceof Observable)) {
            mavContainer.setRequestHandled(true);
            return;
        }

        Observable observable = Observable.class.cast(o);
        WebAsyncUtils.getAsyncManager(nativeWebRequest)
            .startDeferredResultProcessing(new ObservableAdapter(observable), mavContainer);
    }
}

@Slf4j
public static class ObservableAdapter<T> extends DeferredResult<Response<List<T>>> {
    public ObservableAdapter(Observable<T> observable) {
        Disposable subscribe = observable.toList()
            .subscribe(d -> setResult(ResponseHelper.createSuccessResponse(d)), throwable -> {
                if (log.isInfoEnabled()) {
                    log.error("RxJava Observable业务处理失败.", throwable);
                }
            });
        subscribe.dispose();
    }
}
```

这样一来就完成了 SpringMVC、RxJava2 的整合，在 Controller 中可以直接返回 Single、Observable.

***思考:*** 之前一直在思考 RxJava2 对于后台来说因为是异步的，无法返回特定的类，所以一直没有将它放入后台中，但是这次又突然想重新了解一下.所以又去看了一下`豪猪`的代码，因为`豪猪`也是用 Rxjava1 来实现的，为什么它能做到同步的熔断或者降级。看了之后发现原来里面是用 BlockObservable.toFuture() 来实现阻塞返回的。这下我就知道怎么去在 Controller 中整活了，那么我是不是也可以学习一下在业务中，比价耗时的操作用 Observable 或者 Single 来包裹业务代码，之后在需要使用的时候来阻塞获取返回值，试验了一下真的可以，目前确实是这样的做的，但是不知道这样做好不好，后续还会有什么坑需要注意。

之前也确实不知道 toList() 或者 toFuture() 功能具体是什么，但是这次也是努力去看了一下源码实现，发现了也知道了这两个函数的作用，所以对于源码不用感到害怕，就硬着头皮去看，总会看明白的.

> 2021年8月16日

1、【BUG修复】1016573、1016598（刘菲）2.5h 
2、【生产问题】1016511（刘菲）2h
3、安全服务有架构信息整理 文档编写 5h
4、【新需求】只有结束风险才展示持续时间 2h

遗留问题

1. xxl-job 为什么经过多次失败的任务，会将异常信息给截断。不记录完整堆栈日志。

> 2021年8月24日

1、车队管理V2.6.0原型评审会 3h
2、【BUG修复】ID1017630、ID1017642 刘菲 2h
3、配合测试回归生产问题、回归老功能 3h

> 2021年8月25日

1、所有项目部署UAT环境 5.5h
2、定位发车计划监控不到车辆生产问题 3h
3、处理生产tid无法绑定问题 1h
4、TAPD培训0825 1h				

> 2021年8月26日

1、【BUG修复】ID1018215、ID1018222 刘菲 2h
2、UAT 环境部署问题解决、配合测试 7h
3、ID1051285 一汽陆顺-调达二部,一个月车辆液位异常情况提供处理 2h

> 2021年8月27日

1、【BUG修复】ID1018595 刘菲 2h
2、v2.6版本任务拆分 3h
3、v2.6版本部署文档编写 4h

> 2021年8月30

1、一汽陆顺-调达二部车辆补数据，导出数据检查，脚本环境整合 6h
2、车队系统上线支持 7.5
3、车队上线部署文档-配置修改 2h

> 2021年8月31日

1、晚上发布支持 4h
2、油量检测-数据趋势递归查询优化 2h
3、安全分析报告固化任务查询优化 3h

> 2021年9月1日

1、ID 1052527 需求开发 2h
2、处理一汽陆顺-调达二部车辆导出数据 2h
3 、脚本调试 4h

> 2021年9月2日

1、ID1052772 开发 4h
2、排查 ID1052772 补数据后车队页面查不到问题 1h
3、safety 项目数据建模文档编写 3h

> 2021年9月3日

1、编写安全中台数据建模文档 2h
2、安全中台文档评审 1h
3、查询生产问题 3h
4、TDengine 建立数据库相关操作 2h

> 2021年9月8日

平移风险落库逻辑，修改风险时间字段结构 11.5h

> 2021年9月9日

【【安全服务业务模块】业务接口设计需求-【实时风险事件查询（列表）】】11.5h

> 2021年12月15日
1. 主流程测试
2. 功能自测&DBUnit代码编写
3. 车辆日固化零点几问题定位