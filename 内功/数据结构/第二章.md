# 数据结构

## 线性表

### 线性表的基本概念

**线性表**时由 n(n>=0) 个数据元素（节点）$$a_1$$,$$a_2$$，…，$$a_n$$ 组成的有限序列。数据元素的个数 n 定义为表的长度 n=0 时称为空表，记作 ()。

将非空的线性表（n>0）记作 L=（$$a_1$$,$$a_2$$，…，$$a_n$$），$$a_1$$ 称为起始节点，$$a_n$$ 称为终端节点。对任意一队相邻节点 $$a_i$$ 和 $$a_(i+1)$$，$$a_i$$ 称为 $$a_(i+1)$$ 的直接前驱，$$a_(i+1)$$ 称为 $$a_i$$ 的直接后继。

#### 线性表的基本运算

1. 初始化 Initiate(L) 建立一个空表 L=()，L 不含数据元素。
2. 求表长度 Length(L) 返回线性表 L 的长度。
3. 取表元素 Get(L, i) 返回线性表的第i个数据元素，当i不满足 i<=i<=Length(L)时，返回一个特殊值。
4. 定位 Locate(L, x) 查找线性表中数据元素值等于x的节点序号，若由多个数据元素值与x相等，运算结果为这些节点中序号的最小值，若找不到该节点，则运算结果为0。
5. 插入 Insert(L, x, i) 在线性表 L 的第i个数据元素之前插入一个值为x的新数据元素，参数i的合法取值返回是 1<=i<=n+1。操作结束现象表 L 表长度加 1。
6. 删除 Delete(L, i) 删除线性表 L 的第i个数据元素，i的有效范围是 1<=i<=n。删除后线性表 L 表长度减 1。

### 线性表的顺序存储

#### 线性表的顺序实现

线性表顺序存储的方法是：将表中的节点依次存放在计算机内存中**一组连续的存储单元**中，数据元素在线性表中的邻接关系决定它们在存储空间中的存储位置，即逻辑结构中相邻的节点其存储位置也相邻。

用顺序存储实现的线性表称为顺序表。一般用**数组**来表示顺序表。

> 假设已知 $$a_1$$ 地址为 $$Loc(a_1$$)，每个数据元素占 c 个单元，则计算 $$a_i$$ 的地址：$$Loc(a_1)$$ = $$Loc(a_1)$$ + c * (i - 1)

##### 结构体

```c
1.结构体是一种构造数据类型
2.用途：把不同类型的数据组合成一个整体 —— 自定义数据类型
3.引入结构体的好处：加强数据项之间的联系
比如学生的基本信息，包括学号、姓名、性别、年龄、班级、成绩等数据项。这些数据项描述了一个学生的几个不同的侧面。
char no[9] // 学号
char name[20] // 姓名
unsigned int age; // 年龄
unsigned int classno; // 班级
float grade; // 成绩

# 结构体类型定义
# struct 是关键字不能省略
struct 结构体类型名 {
	成员类型1 成员名1;
	成员类型2 成员名2;
};
```

引用方式

1. 结构体变量名.成员名 //非指针型结构体变量的引用
2. 结构体指针->成员名 //指针型结构体变量的引用

##### 初始化

```c
# 顺序表的结构体定义
# define maxsize 100
Const int Maxsize = 100;
typedef struct {
    DataType data[Maxsize];
    int length;
} Seqlist;
Seqlist L;
```

##### 求表长度

```c
int length(SeqList L) {
    return L.length;
}
```

##### 取表元

```c
DataType get(SeqList L, int i) {
    return L.data[i - 1];
}
```

##### 定位

```c
int Locate(SeqList L, DataType x) {
    for(int i = 0; i < L.length; i++) {
        if(L.data[i] == x) {
            return i + 1;
        }
    }
    return 0;
}
```

##### 插入

线性表的插入晕眩是指在表的第i个位置上，插入一个新节点x，使长度为n的线性表变成长度为n+1的线性表。

当表空间已满时，不可再做插入操作、当插入位置为非法位置，不可做正常插入操作。

```c
void InsertSeqlist(SeqList L, DataType x, int i) {
    if(L.length == Maxsize) {
        exit("表已满");
    }
    if(i < 1 || i > L.length + 1) {
        exit("位置错");
    }
    for(j = L.length; j >= i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = x;
    L.length++;
}
# 最坏情况下时间复杂度为 O(n)。一般情况下元素比较和移动的次数为 n-i+1，平均移动次数约为 n/2，时间复杂度为 O(n)
```

##### 删除

```c
void DeleteSeqList(SeqList L, int i) {
    if(i < 1 || i > L.length) {
        exit("位置错");
    }
    for(j = i, j < L.length; j++) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
}
# 最坏的情况下元素的移动次数为 n-1，时间复杂度为 O(n)，元素平均移动次数约为 (n-1)/2，时间复杂度为 O(n)
```

### 结论

1. 顺序表是用一维数组实现的线性表，数组下标可以看成是元素的相对地址
2. 逻辑上相邻的元素，存储在物理位置也相邻的单元中

顺序存储结构的特点

1. 线性表的逻辑结构与存储结构一致
2. 可以对数据元素实现随机读取

```c
# 【分析】根据学生档案信息，给出顺序表具体的类型定义
typedef struct {
    int num;
    char name[8];
    char sex[2];
    int age;
    int score;
} DataType;

const int Maxsize = 7;
typedef struct {
    DataType data[Maxsie];
    int length;
} SeqList;
SeqList student;
```

顺序表的优点

1. 无须为表示节点间的逻辑关系而增加额外存储空间
2. 可以方便地存取表中的任一节点

顺序表的缺点

1. 插入和删除运算不方便，必须移动大量的节点
2. 顺序表要求占用连续的空间，存储分配只能预先进行，因此当表长变化较大时，难以确定合适的存储规模

### 线性表的链接存储

链接方式存储的线性表称为**链表**。

链表的具体存储表示为

1. 用一组任意的存储单元来存放
2. 链表中节点的逻辑次序和物理次序***不一定相同***。还必须存储指示其后继节点的地址信息。

#### 单链表的类型定义

![1619019821360](D:\Typora\image\1619019821360.png)

data 域 —— 存放节点值的数据域

next 域 —— 存放节点的直接后继的地址（位置）的指针域

所有节点通过指针链接而组成单链表 NULL 称为空指针、Head 称为头指针变量，存放在链表中第一个节点地址。

> 指针变量的引用
>
> ***注意：***指针变量中只能存放地址（指针），不要将一个整数（或任何其他非地址类型的数据）赋给一个指针变量。
>
> 与指针变量有关的运算符
>
> 1.&：其功能时返回操作数的内存地址。
>
> 2.*：表示的是地址对应单元中的内容。

##### 单链表的一般图示法

不带头结点的单链表

![1619020191347](D:\Typora\image\1619020191347.png)

带头结点的单链表：单链表中第一个结点内一般不存数据，称为**头结点**。

![1619020230367](D:\Typora\image\1619020230367.png)

##### 单链表的类型定义

```c
# struct node 表示链表的结点，结点包含两个域，数据域 data 和指针域 next。数据域的类型为 DataType，指针域存放该结点直接后继结点的地址，类型为指向 struct node 的指针。定义中通过 typedef 语句把 struct node 类型定义为 Node，把 struct node 指针类型定义为 LinkList。
typedef struct node {
    DataType data;
    struct node *next;
}Node, *LinkList;
```

##### 单链表的特点

1. 起始结点又称为首结点，无前驱，故设头指针 head 指向开始结点。
2. 链表由头指针唯一确定，单链表可以用头指针的名字来命名。头指针命是 head 的链表可称为表 head。
3. 终端结点又称尾结点，无后继，故终端结点的指针域为空，即 NULL。
4. 除头结点之外的结点为表结点。
5. **为运算操作方便**，头结点中不存数据。

> **特别注意：**Head 是什么类型变量？Head 内存放的是什么？
>
> Head 是链表的头指针，所以是指针类型变量。Head 内存放的是头结点的地址。

#### 线性表的基本运算在单链表上的实现

##### 初始化

空表由一个头指针和一个头系欸但组成，因此初始化一个单链表首先需要创建头节点并将其指针域设为 NULL，然后用一个 LinkList 类型（即结点的指针类型）的变量指向新创建的结点，这个 LinkList 类型的变量就作为链表的头指针。

```c
# 在算法中，变量 head 是链表的头指针，它指向新创建的结点，即头结点。一个空链表仅有一个头节点，它的指针域为 NULL。
LinkList InitiateLinkList() {
    LinkList head;
    head = malloc(sizeof(Node));
    head -> next = NULL;
    returen head;
}
```

##### 求表长

在

```c

```

##### 插入

单链表的插入运算是将给定值为x的元素插入到链表 head 的第i个结点之前。要实现这个算法，先找到链表的第 i-1 个结点q，然后生成一个值为x的新结点p，p的指针域指向q的直接后继结点，q的指针域指向p，这样即完成单链表的插入运算。

![1619021800089](D:\Typora\image\1619021800089.png)

```c
void InsertLinklist(LinkList head, DataType x, int i) {
    // 在表 head 的第i个数据结点之前插入一个以x为值的新结点
    Node *p,*q;
    if (i == 1) {
        q = head;
    } else {
        q = GetLinklist(head, i-1);
    }
    if (q == NULL) {
        exit("找不到插入的位置");
    } else {
        p = malloc(sizeof(Node));
        p -> data = x;
        p -> next = q -> next;
        q -> next = p;
    }
}
```

**注意：**值得注意的是链接操作 p -> next = q -> next 和 q -> next = p 两条语句不能颠倒，否则结点 *q 的链域值将丢失。

##### 删除

删除运算是给定一个值i，将链表中第i个结点从链表中移除，并修改相关结点的指针域，以维持剩余结点的链接关系。

![1619022237460](D:\Typora\image\1619022237460.png)

```c
void DeleteLinklist(Linklist head, int i) {
    Node *q;
    if (i == 1) {
        q = head;
    } else {
        q = GetLinklist(head, i-1);
    }
    if (q != NULL && q -> next != NULL) {
        p = q -> next;
        q -> next = p -> next;
        free(p);
    } else {
        exit("找不到要删除的结点");
    }
}
```



### 其他运算在单链表上的实现

#### 建表

#### 删除重复节点

### 其他链表

#### 循环链表

#### 双向循环链表

### 顺序实现与连接实现的比较

### 小结